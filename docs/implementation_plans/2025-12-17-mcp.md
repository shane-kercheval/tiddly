# MCP Server Implementation Plan

## Overview

This plan implements a Model Context Protocol (MCP) server that wraps the bookmarks API, enabling AI agents (e.g., Claude Desktop, Claude Code) to interact with bookmarks using Personal Access Tokens (PATs) for authentication.

**Key Architecture Decision**: MCP is a thin wrapper around the existing API. It extracts the Bearer token from HTTP headers and forwards it to the API. The API handles all authentication and business logic. This ensures a single source of truth - UI, API users, and MCP all use the same interface.

### Goals
- Expose bookmark functionality as MCP tools
- Pass-through authentication via existing PAT system (`bm_` prefixed tokens)
- HTTP transport for both local dev and production (Streamable HTTP)
- Provide tools for: searching bookmarks, getting bookmark details, creating bookmarks, and listing tags

### Non-Goals (Out of Scope)
- OAuth integration (PAT-only authentication)
- Deleting/archiving bookmarks via MCP
- Updating bookmarks via MCP
- Fetching URL metadata via MCP
- MCP Resources or Prompts (tools only for initial implementation)
- View parameter for archived/deleted bookmarks (keep simple)

### Key Design Decisions
- **Stateless HTTP mode**: Since MCP is a thin proxy with no session state, use `stateless_http=True` for horizontal scalability
- **Shared HTTP client**: Use FastMCP lifespan to manage a shared `httpx.AsyncClient` for connection pooling; inject per-request auth headers
- **Transport**: `transport="http"` in FastMCP uses Streamable HTTP (the modern MCP HTTP transport). Endpoint will be at `/mcp`

---

## Documentation References

**Read these before implementing:**
- FastMCP Documentation: https://gofastmcp.com/servers/tools
- FastMCP HTTP Deployment: https://gofastmcp.com/deployment/running-server
- FastMCP Testing: https://gofastmcp.com/patterns/testing
- MCP Protocol Overview: https://modelcontextprotocol.io/docs/learn/server-concepts
- MCP Inspector: https://modelcontextprotocol.io/docs/tools/inspector

---

## Milestone 1: Project Setup and API Client

### Goal
Set up the MCP server infrastructure with an HTTP client that forwards requests to the existing API. MCP is a thin wrapper - the API handles all authentication and business logic.

### Success Criteria
- FastMCP server initializes and runs via HTTP transport
- API client can make authenticated requests to the bookmarks API
- Bearer token is extracted from HTTP headers and forwarded to API
- MCP Inspector can connect and list tools

### Key Changes

1. **Add dependencies**
   ```bash
   uv add fastmcp httpx
   uv add --dev respx
   ```

2. **Create MCP server module** (`backend/src/mcp/`)
   ```
   backend/src/mcp/
   ├── __init__.py
   ├── __main__.py       # Entry point
   ├── server.py         # FastMCP server instance and tools
   └── api_client.py     # HTTP client for API calls
   ```

3. **Create API client module** (`backend/src/mcp/api_client.py`)

   Helper functions for making authenticated API requests using the shared HTTP client:
   ```python
   import os
   from typing import Any

   import httpx

   API_BASE_URL = os.getenv("API_BASE_URL", "http://localhost:8000")
   DEFAULT_TIMEOUT = 30.0


   def get_api_base_url() -> str:
       """Get the API base URL from environment."""
       return API_BASE_URL


   def get_default_timeout() -> float:
       """Get the default request timeout."""
       return DEFAULT_TIMEOUT


   async def api_get(
       client: httpx.AsyncClient,
       path: str,
       token: str,
       params: dict[str, Any] | None = None,
   ) -> dict[str, Any]:
       """Make an authenticated GET request to the API."""
       response = await client.get(
           path,
           params=params,
           headers={"Authorization": f"Bearer {token}"},
       )
       response.raise_for_status()
       return response.json()


   async def api_post(
       client: httpx.AsyncClient,
       path: str,
       token: str,
       json: dict[str, Any],
   ) -> dict[str, Any]:
       """Make an authenticated POST request to the API."""
       response = await client.post(
           path,
           json=json,
           headers={"Authorization": f"Bearer {token}"},
       )
       response.raise_for_status()
       return response.json()
   ```

4. **Create token extraction utility** (`backend/src/mcp/auth.py`)

   Extract Bearer token from HTTP headers (pass-through approach):
   ```python
   from fastmcp.server.dependencies import get_http_headers


   class AuthenticationError(Exception):
       """Raised when authentication fails."""
       pass


   def get_bearer_token() -> str:
       """
       Extract Bearer token from the Authorization header.

       Returns:
           The token string (without 'Bearer ' prefix).

       Raises:
           AuthenticationError: If no valid Bearer token is present.
       """
       headers = get_http_headers()
       auth_header = headers.get("authorization", "")

       if not auth_header.lower().startswith("bearer "):
           raise AuthenticationError("Missing or invalid Authorization header")

       token = auth_header[7:]  # Remove "Bearer " prefix
       if not token:
           raise AuthenticationError("Empty Bearer token")

       return token
   ```

5. **Create FastMCP server instance with lifespan** (`backend/src/mcp/server.py`)
   ```python
   from contextlib import asynccontextmanager
   from dataclasses import dataclass

   import httpx
   from fastmcp import FastMCP

   from .api_client import get_api_base_url, get_default_timeout


   @dataclass
   class AppState:
       """Application state managed by lifespan."""
       http_client: httpx.AsyncClient


   @asynccontextmanager
   async def lifespan(server: FastMCP):
       """Manage shared HTTP client lifecycle."""
       async with httpx.AsyncClient(
           base_url=get_api_base_url(),
           timeout=get_default_timeout(),
       ) as client:
           yield AppState(http_client=client)


   mcp = FastMCP(
       name="Bookmarks MCP Server",
       stateless_http=True,
       lifespan=lifespan,
   )

   # Tools will be added in Milestone 2
   ```

6. **Create entry point** (`backend/src/mcp/__main__.py`)
   ```python
   from .server import mcp

   if __name__ == "__main__":
       mcp.run(transport="http", host="0.0.0.0", port=8001)
   ```

### Testing Strategy
- Unit test API client with mocked httpx responses using `respx`
- Unit test token extraction with mocked headers
- Verify MCP server starts: `uv run python -m backend.src.mcp`

### Dependencies
- None (first milestone)

### Risk Factors
- Verify `get_http_headers()` is available and works as expected in FastMCP
- API must be running for MCP to work (document this requirement)

---

## Milestone 2: Core Tools Implementation

### Goal
Implement the four core MCP tools that wrap API endpoints: `search_bookmarks`, `get_bookmark`, `create_bookmark`, and `list_tags`.

### Success Criteria
- All four tools are registered and callable via MCP
- Tools make HTTP calls to the corresponding API endpoints
- API errors are translated to meaningful MCP errors with rich details
- Tools work with valid PAT, fail appropriately with invalid PAT

### Key Changes

1. **Implement `search_bookmarks` tool** (`backend/src/mcp/server.py`)

   The complete server.py with lifespan, helpers, and the first tool:
   ```python
   from contextlib import asynccontextmanager
   from dataclasses import dataclass
   from typing import Annotated, Any, Literal

   import httpx
   from fastmcp import FastMCP
   from fastmcp.exceptions import ToolError
   from fastmcp.server.dependencies import get_context
   from pydantic import Field

   from .api_client import api_get, api_post, get_api_base_url, get_default_timeout
   from .auth import AuthenticationError, get_bearer_token


   @dataclass
   class AppState:
       """Application state managed by lifespan."""
       http_client: httpx.AsyncClient


   @asynccontextmanager
   async def lifespan(server: FastMCP):
       """Manage shared HTTP client lifecycle."""
       async with httpx.AsyncClient(
           base_url=get_api_base_url(),
           timeout=get_default_timeout(),
       ) as client:
           yield AppState(http_client=client)


   mcp = FastMCP(
       name="Bookmarks MCP Server",
       stateless_http=True,
       lifespan=lifespan,
   )


   def _get_http_client() -> httpx.AsyncClient:
       """Get the shared HTTP client from lifespan state."""
       ctx = get_context()
       state: AppState = ctx.fastmcp.lifespan_state
       return state.http_client


   def _get_token() -> str:
       """Get Bearer token, raising ToolError on failure."""
       try:
           return get_bearer_token()
       except AuthenticationError as e:
           raise ToolError(str(e))


   def _handle_api_error(e: httpx.HTTPStatusError, context: str = "") -> None:
       """Translate API errors to meaningful MCP ToolErrors."""
       status = e.response.status_code

       if status == 401:
           raise ToolError("Invalid or expired token")
       if status == 403:
           raise ToolError("Access denied")

       # Try to extract detailed error message
       try:
           detail = e.response.json().get("detail", {})
           if isinstance(detail, dict):
               message = detail.get("message", str(detail))
               error_code = detail.get("error_code", "")
               if error_code:
                   raise ToolError(f"{message} (code: {error_code})")
               raise ToolError(message)
           raise ToolError(str(detail))
       except (ValueError, KeyError):
           raise ToolError(f"API error {status}{': ' + context if context else ''}")


   @mcp.tool(
       description="Search bookmarks with optional text query and tag filtering. Returns active bookmarks only.",
       annotations={"readOnlyHint": True},
   )
   async def search_bookmarks(
       query: Annotated[str | None, Field(description="Text to search in title, URL, description, and content")] = None,
       tags: Annotated[list[str] | None, Field(description="Filter by tags")] = None,
       tag_match: Annotated[Literal["all", "any"], Field(description="Tag matching: 'all' requires ALL tags, 'any' requires ANY tag")] = "all",
       sort_by: Annotated[Literal["created_at", "updated_at", "last_used_at", "title"], Field(description="Field to sort by")] = "created_at",
       sort_order: Annotated[Literal["asc", "desc"], Field(description="Sort direction")] = "desc",
       limit: Annotated[int, Field(ge=1, le=100, description="Maximum results to return")] = 50,
       offset: Annotated[int, Field(ge=0, description="Number of results to skip for pagination")] = 0,
   ) -> dict[str, Any]:
       """
       Search and filter bookmarks.

       Examples:
       - Search for "python": query="python"
       - Filter by tag: tags=["programming"]
       - Combine: query="tutorial", tags=["python", "beginner"], tag_match="all"
       """
       client = _get_http_client()
       token = _get_token()

       params: dict[str, Any] = {
           "limit": limit,
           "offset": offset,
           "tag_match": tag_match,
           "sort_by": sort_by,
           "sort_order": sort_order,
       }
       if query:
           params["q"] = query
       if tags:
           params["tags"] = tags  # FastAPI handles list params

       try:
           return await api_get(client, "/bookmarks/", token, params)
       except httpx.HTTPStatusError as e:
           _handle_api_error(e, "searching bookmarks")
       except httpx.RequestError as e:
           raise ToolError(f"API unavailable: {e}")
   ```

2. **Implement `get_bookmark` tool**
   ```python
   @mcp.tool(
       description="Get the full details of a specific bookmark including stored content",
       annotations={"readOnlyHint": True},
   )
   async def get_bookmark(
       bookmark_id: Annotated[int, Field(description="The ID of the bookmark to retrieve")],
   ) -> dict[str, Any]:
       """Get a bookmark by ID. Returns full details including content if stored."""
       client = _get_http_client()
       token = _get_token()

       try:
           return await api_get(client, f"/bookmarks/{bookmark_id}", token)
       except httpx.HTTPStatusError as e:
           if e.response.status_code == 404:
               raise ToolError(f"Bookmark with ID {bookmark_id} not found")
           _handle_api_error(e, f"getting bookmark {bookmark_id}")
       except httpx.RequestError as e:
           raise ToolError(f"API unavailable: {e}")
   ```

3. **Implement `create_bookmark` tool**
   ```python
   @mcp.tool(
       description="Create a new bookmark. URL metadata (title, description) will be auto-fetched if not provided.",
       annotations={"readOnlyHint": False},
   )
   async def create_bookmark(
       url: Annotated[str, Field(description="The URL to bookmark")],
       title: Annotated[str | None, Field(description="Title (auto-fetched from URL if not provided)")] = None,
       description: Annotated[str | None, Field(description="Description (auto-fetched from URL if not provided)")] = None,
       tags: Annotated[list[str] | None, Field(description="Tags to assign (lowercase alphanumeric with hyphens, e.g., 'machine-learning')")] = None,
       store_content: Annotated[bool, Field(description="Whether to store the page content for search")] = True,
   ) -> dict[str, Any]:
       """
       Create a new bookmark.

       If title and description are not provided, they will be automatically
       fetched from the URL. Tags should be lowercase with hyphens (e.g., 'web-dev').
       """
       client = _get_http_client()
       token = _get_token()

       payload: dict[str, Any] = {"url": url, "store_content": store_content}
       if title is not None:
           payload["title"] = title
       if description is not None:
           payload["description"] = description
       if tags is not None:
           payload["tags"] = tags

       try:
           return await api_post(client, "/bookmarks/", token, payload)
       except httpx.HTTPStatusError as e:
           if e.response.status_code == 409:
               # Extract rich error details
               try:
                   detail = e.response.json().get("detail", {})
                   error_code = detail.get("error_code", "")
                   if error_code == "ARCHIVED_URL_EXISTS":
                       bookmark_id = detail.get("existing_bookmark_id")
                       raise ToolError(
                           f"An archived bookmark exists with this URL (ID: {bookmark_id}). "
                           "Use the web UI to restore or permanently delete it first."
                       )
                   raise ToolError("A bookmark with this URL already exists")
               except (ValueError, KeyError, TypeError):
                   raise ToolError("A bookmark with this URL already exists")
           _handle_api_error(e, "creating bookmark")
       except httpx.RequestError as e:
           raise ToolError(f"API unavailable: {e}")
   ```

4. **Implement `list_tags` tool**
   ```python
   @mcp.tool(
       description="List all tags with their usage counts (number of active bookmarks using each tag)",
       annotations={"readOnlyHint": True},
   )
   async def list_tags() -> dict[str, Any]:
       """
       Get all tags for the authenticated user.

       Returns tags sorted by usage count (most used first), then alphabetically.
       Includes tags with zero active bookmarks.
       """
       client = _get_http_client()
       token = _get_token()

       try:
           return await api_get(client, "/tags/", token)
       except httpx.HTTPStatusError as e:
           _handle_api_error(e, "listing tags")
       except httpx.RequestError as e:
           raise ToolError(f"API unavailable: {e}")
   ```

### Testing Strategy
- Unit tests for each tool using FastMCP Client with mocked API responses using `respx`
- Test error handling: 401 (invalid token), 404 (not found), 409 (duplicate with both error codes), network errors
- Test parameter validation (limit bounds, tag_match values)
- Test with MCP Inspector manually

### Dependencies
- Milestone 1 (API client and auth)

### Risk Factors
- Verify `get_http_headers()` returns lowercase header names

---

## Milestone 3: Testing Infrastructure

### Goal
Comprehensive automated test coverage for MCP components, eliminating reliance on manual testing.

### Success Criteria
- Unit tests for API client with mocked HTTP responses
- Unit tests for token extraction
- Integration tests for MCP tools using in-memory client
- All tests run without requiring the API to be running
- Tests integrated into `make unit_tests`

### Key Changes

1. **Create test module** (`backend/tests/mcp/`)
   ```
   backend/tests/mcp/
   ├── __init__.py
   ├── conftest.py           # MCP-specific fixtures
   ├── test_api_client.py    # API client tests
   ├── test_auth.py          # Token extraction tests
   └── test_tools.py         # Tool execution tests
   ```

2. **Test fixtures** (`backend/tests/mcp/conftest.py`)
   ```python
   import pytest
   import respx
   from unittest.mock import patch

   from fastmcp import Client


   @pytest.fixture
   def mock_api():
       """Context manager for mocking API responses."""
       with respx.mock(base_url="http://localhost:8000") as respx_mock:
           yield respx_mock


   @pytest.fixture
   def mock_auth():
       """Mock authentication for tool tests."""
       with patch("backend.src.mcp.server.get_bearer_token") as mock:
           mock.return_value = "bm_test_token"
           yield mock


   @pytest.fixture
   async def mcp_client(mock_auth):
       """Create an MCP client connected to the server."""
       from backend.src.mcp.server import mcp
       async with Client(transport=mcp) as client:
           yield client


   # Sample response data for reuse
   @pytest.fixture
   def sample_bookmark() -> dict:
       return {
           "id": 1,
           "url": "https://example.com",
           "title": "Example Site",
           "description": "An example website",
           "content": "Page content here",
           "tags": ["example", "test"],
           "created_at": "2024-01-01T00:00:00Z",
           "updated_at": "2024-01-01T00:00:00Z",
           "last_used_at": "2024-01-01T00:00:00Z",
           "deleted_at": None,
           "archived_at": None,
       }


   @pytest.fixture
   def sample_bookmark_list(sample_bookmark: dict) -> dict:
       return {
           "items": [sample_bookmark],
           "total": 1,
           "offset": 0,
           "limit": 50,
           "has_more": False,
       }


   @pytest.fixture
   def sample_tags() -> dict:
       return {
           "tags": [
               {"name": "python", "count": 10},
               {"name": "javascript", "count": 5},
               {"name": "web-dev", "count": 3},
           ]
       }
   ```

3. **API client tests** (`backend/tests/mcp/test_api_client.py`)
   ```python
   import httpx
   import pytest
   import respx
   from httpx import Response

   from backend.src.mcp.api_client import api_get, api_post


   @pytest.mark.asyncio
   async def test__api_get__success(mock_api) -> None:
       """Test successful GET request."""
       mock_api.get("/bookmarks/1").mock(
           return_value=Response(200, json={"id": 1, "url": "https://example.com"})
       )

       async with httpx.AsyncClient(base_url="http://localhost:8000") as client:
           result = await api_get(client, "/bookmarks/1", "bm_test_token")

       assert result["id"] == 1
       assert result["url"] == "https://example.com"


   @pytest.mark.asyncio
   async def test__api_get__with_params(mock_api) -> None:
       """Test GET request with query parameters."""
       mock_api.get("/bookmarks/").mock(
           return_value=Response(200, json={"items": [], "total": 0})
       )

       async with httpx.AsyncClient(base_url="http://localhost:8000") as client:
           result = await api_get(client, "/bookmarks/", "bm_test_token", params={"q": "test", "limit": 10})

       assert result["total"] == 0


   @pytest.mark.asyncio
   async def test__api_post__success(mock_api) -> None:
       """Test successful POST request."""
       mock_api.post("/bookmarks/").mock(
           return_value=Response(201, json={"id": 1, "url": "https://example.com"})
       )

       async with httpx.AsyncClient(base_url="http://localhost:8000") as client:
           result = await api_post(client, "/bookmarks/", "bm_test_token", {"url": "https://example.com"})

       assert result["id"] == 1


   @pytest.mark.asyncio
   async def test__api_get__http_error(mock_api) -> None:
       """Test HTTP error handling."""
       mock_api.get("/bookmarks/999").mock(
           return_value=Response(404, json={"detail": "Not found"})
       )

       async with httpx.AsyncClient(base_url="http://localhost:8000") as client:
           with pytest.raises(httpx.HTTPStatusError):
               await api_get(client, "/bookmarks/999", "bm_test_token")


   @pytest.mark.asyncio
   async def test__api_get__authorization_header_set(mock_api) -> None:
       """Test that Authorization header is correctly set."""
       mock_api.get("/test").mock(return_value=Response(200, json={}))

       async with httpx.AsyncClient(base_url="http://localhost:8000") as client:
           await api_get(client, "/test", "bm_test_token_12345")

       assert mock_api.calls[0].request.headers["authorization"] == "Bearer bm_test_token_12345"
   ```

4. **Auth tests** (`backend/tests/mcp/test_auth.py`)
   ```python
   import pytest
   from unittest.mock import patch

   from backend.src.mcp.auth import AuthenticationError, get_bearer_token


   def test__get_bearer_token__valid() -> None:
       """Test extracting valid Bearer token."""
       with patch("backend.src.mcp.auth.get_http_headers") as mock_headers:
           mock_headers.return_value = {"authorization": "Bearer bm_test_token"}

           token = get_bearer_token()

           assert token == "bm_test_token"


   def test__get_bearer_token__case_insensitive() -> None:
       """Test Bearer prefix is case-insensitive."""
       with patch("backend.src.mcp.auth.get_http_headers") as mock_headers:
           mock_headers.return_value = {"authorization": "bearer bm_test_token"}

           token = get_bearer_token()

           assert token == "bm_test_token"


   def test__get_bearer_token__missing_header() -> None:
       """Test error when Authorization header is missing."""
       with patch("backend.src.mcp.auth.get_http_headers") as mock_headers:
           mock_headers.return_value = {}

           with pytest.raises(AuthenticationError, match="Missing or invalid"):
               get_bearer_token()


   def test__get_bearer_token__invalid_scheme() -> None:
       """Test error when not using Bearer scheme."""
       with patch("backend.src.mcp.auth.get_http_headers") as mock_headers:
           mock_headers.return_value = {"authorization": "Basic abc123"}

           with pytest.raises(AuthenticationError, match="Missing or invalid"):
               get_bearer_token()


   def test__get_bearer_token__empty_token() -> None:
       """Test error when token is empty."""
       with patch("backend.src.mcp.auth.get_http_headers") as mock_headers:
           mock_headers.return_value = {"authorization": "Bearer "}

           with pytest.raises(AuthenticationError, match="Empty Bearer token"):
               get_bearer_token()
   ```

5. **Tool tests** (`backend/tests/mcp/test_tools.py`)
   ```python
   import pytest
   import respx
   from httpx import Response
   from unittest.mock import patch

   # Import after mocking to ensure proper setup
   from backend.src.mcp.server import search_bookmarks, get_bookmark, create_bookmark, list_tags


   @pytest.fixture(autouse=True)
   def mock_auth():
       """Mock authentication for all tool tests."""
       with patch("backend.src.mcp.server.get_bearer_token") as mock:
           mock.return_value = "bm_test_token"
           yield mock


   @pytest.mark.asyncio
   async def test__search_bookmarks__basic(mock_api, sample_bookmark_list: dict) -> None:
       """Test basic bookmark search."""
       mock_api.get("/bookmarks/").mock(
           return_value=Response(200, json=sample_bookmark_list)
       )

       result = await search_bookmarks()

       assert result["total"] == 1
       assert len(result["items"]) == 1


   @pytest.mark.asyncio
   async def test__search_bookmarks__with_query(mock_api, sample_bookmark_list: dict) -> None:
       """Test search with query parameter."""
       mock_api.get("/bookmarks/").mock(
           return_value=Response(200, json=sample_bookmark_list)
       )

       result = await search_bookmarks(query="example")

       assert "q" in str(mock_api.calls[0].request.url)


   @pytest.mark.asyncio
   async def test__search_bookmarks__with_tags(mock_api, sample_bookmark_list: dict) -> None:
       """Test search with tag filtering."""
       mock_api.get("/bookmarks/").mock(
           return_value=Response(200, json=sample_bookmark_list)
       )

       result = await search_bookmarks(tags=["python", "web-dev"], tag_match="any")

       request_url = str(mock_api.calls[0].request.url)
       assert "tags" in request_url
       assert "tag_match=any" in request_url


   @pytest.mark.asyncio
   async def test__get_bookmark__success(mock_api, sample_bookmark: dict) -> None:
       """Test getting a bookmark by ID."""
       mock_api.get("/bookmarks/1").mock(
           return_value=Response(200, json=sample_bookmark)
       )

       result = await get_bookmark(bookmark_id=1)

       assert result["id"] == 1
       assert result["url"] == "https://example.com"


   @pytest.mark.asyncio
   async def test__get_bookmark__not_found(mock_api) -> None:
       """Test 404 error handling."""
       mock_api.get("/bookmarks/999").mock(
           return_value=Response(404, json={"detail": "Not found"})
       )

       from fastmcp.exceptions import ToolError
       with pytest.raises(ToolError, match="not found"):
           await get_bookmark(bookmark_id=999)


   @pytest.mark.asyncio
   async def test__create_bookmark__success(mock_api, sample_bookmark: dict) -> None:
       """Test creating a bookmark."""
       mock_api.post("/bookmarks/").mock(
           return_value=Response(201, json=sample_bookmark)
       )

       result = await create_bookmark(
           url="https://example.com",
           title="Example",
           tags=["test"],
       )

       assert result["id"] == 1


   @pytest.mark.asyncio
   async def test__create_bookmark__duplicate_active(mock_api) -> None:
       """Test duplicate URL error (active bookmark exists)."""
       mock_api.post("/bookmarks/").mock(
           return_value=Response(409, json={
               "detail": {
                   "message": "URL already exists",
                   "error_code": "ACTIVE_URL_EXISTS",
               }
           })
       )

       from fastmcp.exceptions import ToolError
       with pytest.raises(ToolError, match="already exists"):
           await create_bookmark(url="https://example.com")


   @pytest.mark.asyncio
   async def test__create_bookmark__archived_exists(mock_api) -> None:
       """Test duplicate URL error (archived bookmark exists)."""
       mock_api.post("/bookmarks/").mock(
           return_value=Response(409, json={
               "detail": {
                   "message": "Archived bookmark exists",
                   "error_code": "ARCHIVED_URL_EXISTS",
                   "existing_bookmark_id": 42,
               }
           })
       )

       from fastmcp.exceptions import ToolError
       with pytest.raises(ToolError, match="archived.*ID: 42"):
           await create_bookmark(url="https://example.com")


   @pytest.mark.asyncio
   async def test__list_tags__success(mock_api, sample_tags: dict) -> None:
       """Test listing tags."""
       mock_api.get("/tags/").mock(
           return_value=Response(200, json=sample_tags)
       )

       result = await list_tags()

       assert len(result["tags"]) == 3
       assert result["tags"][0]["name"] == "python"
   ```

### Testing Strategy
- Run with: `make unit_tests` (existing infrastructure)
- Tests use `respx` to mock HTTP responses at the transport level
- Tests use `unittest.mock.patch` to mock `get_http_headers` and `get_bearer_token`
- No API or MCP server needs to be running

### Dependencies
- Milestones 1-2

### Risk Factors
- Ensure `respx` mocking works correctly with `httpx.AsyncClient`
- May need to adjust imports to avoid circular dependencies

---

## Milestone 4: HTTP Transport and Documentation

### Goal
Finalize HTTP transport configuration and provide clear documentation for developers.

### Success Criteria
- MCP server runs reliably on HTTP transport
- README documents setup for Claude Code, Claude Desktop, and MCP Inspector
- Makefile includes MCP commands

### Key Changes

1. **Update Makefile**
   ```makefile
   # MCP Server
   mcp-run:
   	@echo "Starting MCP server on port 8001..."
   	@echo "API must be running on port 8000"
   	uv run python -m backend.src.mcp

   mcp-inspect:
   	@echo "Starting MCP Inspector..."
   	@echo "Once running, connect to: http://localhost:8001/mcp"
   	npx @modelcontextprotocol/inspector
   ```

2. **Add MCP section to README.md**
   ```markdown
   ## MCP Server (AI Agent Integration)

   The bookmarks API can be accessed by AI agents via the Model Context Protocol (MCP).

   ### Prerequisites
   - Create a Personal Access Token (PAT) in the web UI (Settings > API Tokens)
   - Your PAT will start with `bm_` - save it securely
   - The API server must be running (`make run`)

   ### Running the MCP Server
   ```bash
   # Start the API (Terminal 1)
   make run

   # Start the MCP server (Terminal 2)
   make mcp-run
   ```
   The MCP server runs on `http://localhost:8001/mcp`.

   ### Testing with MCP Inspector
   ```bash
   # Start the Inspector
   make mcp-inspect

   # In the Inspector UI:
   # 1. Transport: Streamable HTTP
   # 2. URL: http://localhost:8001/mcp
   # 3. Add header: Authorization: Bearer bm_your_token_here
   # 4. Click Connect
   ```

   ### Connecting Claude Code
   ```bash
   claude mcp add --transport http bookmarks http://localhost:8001/mcp \
     --header "Authorization: Bearer bm_your_token_here"
   ```

   ### Connecting Claude Desktop

   **For Claude Pro/Max/Team/Enterprise users:**
   1. Open Claude Desktop > Settings > Connectors
   2. Click "Add custom connector"
   3. Enter URL: `http://localhost:8001/mcp`
   4. Enter your PAT when prompted for authentication

   **For other users (using mcp-remote proxy):**

   Edit `~/Library/Application Support/Claude/claude_desktop_config.json` (macOS) or
   `%APPDATA%\Claude\claude_desktop_config.json` (Windows):

   ```json
   {
     "mcpServers": {
       "bookmarks": {
         "command": "npx",
         "args": [
           "mcp-remote",
           "http://localhost:8001/mcp",
           "--header",
           "Authorization:Bearer ${BOOKMARKS_PAT}"
         ],
         "env": {
           "BOOKMARKS_PAT": "bm_your_token_here"
         }
       }
     }
   }
   ```

   Restart Claude Desktop after editing the config.

   ### Available Tools

   | Tool | Description |
   |------|-------------|
   | `search_bookmarks` | Search bookmarks with text query and tag filtering |
   | `get_bookmark` | Get full details of a bookmark by ID |
   | `create_bookmark` | Create a new bookmark (auto-fetches metadata) |
   | `list_tags` | List all tags with usage counts |

   ### Example Usage (in Claude)
   - "Search my bookmarks for Python tutorials"
   - "Show me bookmarks tagged with 'machine-learning'"
   - "Save this URL as a bookmark: https://example.com"
   - "What tags do I have?"
   ```

### Testing Strategy
- Manual testing with MCP Inspector to verify HTTP transport
- Manual testing with Claude Code CLI
- Verify documentation is accurate

### Dependencies
- Milestones 1-3

### Risk Factors
- Claude Desktop config varies by subscription tier
- `mcp-remote` package may have updates that change syntax

---

## Architecture Summary

```
┌─────────────────────────────────────────────────────────────┐
│              Claude Desktop / Claude Code / AI Agent         │
└─────────────────────────────────────────────────────────────┘
                              │
                    PAT Token (Authorization: Bearer bm_xxx)
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                    MCP Server (FastMCP)                      │
│                         Port 8001                            │
│  ┌─────────────────────────────────────────────────────────┐ │
│  │                    Tools (server.py)                    │ │
│  │  - search_bookmarks    - get_bookmark                   │ │
│  │  - create_bookmark     - list_tags                      │ │
│  └─────────────────────────────────────────────────────────┘ │
│                              │                               │
│  ┌─────────────────────────────────────────────────────────┐ │
│  │              Auth (auth.py) - Pass-through              │ │
│  │  - Extracts Bearer token from HTTP headers              │ │
│  │  - No validation (API handles it)                       │ │
│  └─────────────────────────────────────────────────────────┘ │
│                              │                               │
│  ┌─────────────────────────────────────────────────────────┐ │
│  │                 API Client (api_client.py)              │ │
│  │  - Forwards Bearer token to API                         │ │
│  │  - Connection pooling via shared httpx client           │ │
│  └─────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────┘
                              │
                    HTTP (Bearer token forwarded)
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                   Bookmarks API (FastAPI)                    │
│                         Port 8000                            │
│  - Validates PAT tokens                                      │
│  - Handles all business logic                                │
│  - Single source of truth                                    │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                        PostgreSQL                            │
└─────────────────────────────────────────────────────────────┘
```

---

## File Structure

```
backend/src/
├── mcp/
│   ├── __init__.py
│   ├── __main__.py         # Entry point (runs HTTP server on port 8001)
│   ├── server.py           # FastMCP instance and tool definitions
│   ├── api_client.py       # HTTP client for API calls
│   └── auth.py             # Token extraction (pass-through)
├── api/                     # Existing API (unchanged)
├── services/                # Existing services (used by API, not MCP directly)
└── ...

backend/tests/
├── mcp/
│   ├── __init__.py
│   ├── conftest.py         # Fixtures and sample data
│   ├── test_api_client.py  # API client tests
│   ├── test_auth.py        # Token extraction tests
│   └── test_tools.py       # Tool execution tests
└── ...
```

---

## Implementation Checklist

### Milestone 1: Project Setup
- [ ] Add `fastmcp` and `httpx` dependencies
- [ ] Add `respx` dev dependency
- [ ] Create `backend/src/mcp/` directory structure
- [ ] Implement `api_client.py`
- [ ] Implement `auth.py`
- [ ] Create basic `server.py` with FastMCP instance
- [ ] Create `__main__.py` entry point
- [ ] Verify server starts with `uv run python -m backend.src.mcp`

### Milestone 2: Core Tools
- [ ] Implement `search_bookmarks` tool
- [ ] Implement `get_bookmark` tool
- [ ] Implement `create_bookmark` tool
- [ ] Implement `list_tags` tool
- [ ] Add comprehensive error handling
- [ ] Test with MCP Inspector

### Milestone 3: Testing
- [ ] Create `backend/tests/mcp/` directory structure
- [ ] Implement `conftest.py` with fixtures
- [ ] Implement `test_api_client.py`
- [ ] Implement `test_auth.py`
- [ ] Implement `test_tools.py`
- [ ] Verify all tests pass with `make unit_tests`

### Milestone 4: Documentation
- [ ] Add MCP commands to Makefile
- [ ] Add MCP section to README.md
- [ ] Test with Claude Code CLI
- [ ] Test with Claude Desktop (if available)
