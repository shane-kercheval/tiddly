# MCP Tools for Notes - Implementation Plan

**Date:** 2025-12-28
**Status:** Ready for Implementation
**Scope:** Add MCP tools for notes and unified content search

---

## Overview

### Current State

The MCP server (`backend/src/mcp_server/server.py`) currently has 4 tools:
- `search_bookmarks` - Search bookmarks by query/tags
- `get_bookmark` - Get bookmark by ID
- `create_bookmark` - Create a new bookmark
- `list_tags` - List all tags with counts

The backend already has complete Note endpoints (from Milestone 4):
- `GET /notes/` - List/search notes
- `GET /notes/{id}` - Get single note
- `POST /notes/` - Create note
- Plus archive, delete, restore endpoints

The backend also has a unified content endpoint:
- `GET /content/` - Search across bookmarks and notes

### Goal

Add MCP tools for notes to provide feature parity with bookmarks, plus a unified search tool.

### Final Tool List (8 tools)

| Tool | Status | Description |
|------|--------|-------------|
| `search_bookmarks` | KEEP | Search bookmarks |
| `search_notes` | NEW | Search notes |
| `search_all_content` | NEW | Unified search across types |
| `get_bookmark` | KEEP | Get bookmark by ID |
| `get_note` | NEW | Get note by ID |
| `create_bookmark` | KEEP | Create bookmark |
| `create_note` | NEW | Create note |
| `list_tags` | KEEP | List all tags (shared) |

---

## Implementation Guidelines

### Code Snippets Are Illustrative

The code snippets in this plan are **recommended implementations**, not prescriptions. The implementing agent should:

- **Read existing code first** - Study `server.py` and `test_tools.py` to understand actual patterns before implementing
- **Adapt as needed** - If the existing code differs from the snippets here, follow the existing patterns
- **Use judgment** - If unforeseen situations arise, make reasonable adjustments rather than blindly following this plan
- **Ask questions** - If something is unclear or seems wrong, ask for clarification

### Testing Philosophy

For tests, the agent should:

- **Follow existing test patterns** in `backend/tests/mcp_server/test_tools.py` exactly
- **Test thoroughly** - Cover success cases, error cases, edge cases, and parameter variations
- **Don't limit to examples** - The test examples here are illustrative; add more tests if the existing patterns suggest additional coverage is needed
- **Match naming conventions** - Use the `test__<function>__<scenario>` pattern consistently

### Key Files to Read First

Before implementing, the agent MUST read and understand:

1. `backend/src/mcp_server/server.py` - Existing tool implementations
2. `backend/tests/mcp_server/test_tools.py` - Existing test patterns
3. `backend/tests/mcp_server/conftest.py` - Existing fixtures
4. `backend/src/api/routers/notes.py` - Note API endpoints being called
5. `backend/src/api/routers/content.py` - Content API endpoint being called

---

## Milestone 1: Test Fixtures and `search_notes` Tool

### Goal

Add test fixtures for notes and implement the `search_notes` MCP tool.

### Dependencies

None - this is the first milestone.

### Success Criteria

- [ ] Note test fixtures added to `conftest.py`
- [ ] `search_notes` tool implemented in `server.py`
- [ ] All tests for `search_notes` pass
- [ ] `make linting` passes
- [ ] `make unit_tests` passes

### Key Changes

#### 1. Add Test Fixtures

**File:** `backend/tests/mcp_server/conftest.py`

Add fixtures after `sample_tags` (around line 70):

```python
@pytest.fixture
def sample_note() -> dict[str, Any]:
    """Sample note response data."""
    return {
        "id": 1,
        "title": "Test Note",
        "description": "A test note description",
        "content": "# Markdown Content\n\nThis is the note body.",
        "tags": ["notes", "test"],
        "created_at": "2024-01-01T00:00:00Z",
        "updated_at": "2024-01-01T00:00:00Z",
        "last_used_at": "2024-01-01T00:00:00Z",
        "deleted_at": None,
        "archived_at": None,
        "version": 1,
    }


@pytest.fixture
def sample_note_list(sample_note: dict[str, Any]) -> dict[str, Any]:
    """Sample paginated note list response."""
    return {
        "items": [sample_note],
        "total": 1,
        "offset": 0,
        "limit": 50,
        "has_more": False,
    }
```

#### 2. Add `search_notes` Tool

**File:** `backend/src/mcp_server/server.py`

Add after `search_bookmarks` (around line 148). Follow the exact pattern of `search_bookmarks`:

```python
@mcp.tool(
    description=(
        "Search notes with optional text query and tag filtering. "
        "Returns active notes only."
    ),
    annotations={"readOnlyHint": True},
)
async def search_notes(
    query: Annotated[
        str | None,
        Field(description="Text to search in title, description, and content"),
    ] = None,
    tags: Annotated[list[str] | None, Field(description="Filter by tags")] = None,
    tag_match: Annotated[
        Literal["all", "any"],
        Field(description="Tag matching: 'all' requires ALL tags, 'any' requires ANY tag"),
    ] = "all",
    sort_by: Annotated[
        Literal["created_at", "updated_at", "last_used_at", "title"],
        Field(description="Field to sort by"),
    ] = "created_at",
    sort_order: Annotated[Literal["asc", "desc"], Field(description="Sort direction")] = "desc",
    limit: Annotated[int, Field(ge=1, le=100, description="Maximum results to return")] = 50,
    offset: Annotated[
        int, Field(ge=0, description="Number of results to skip for pagination"),
    ] = 0,
) -> dict[str, Any]:
    """
    Search and filter notes.

    Examples:
    - Search for "meeting": query="meeting"
    - Filter by tag: tags=["work"]
    - Combine: query="project", tags=["work", "important"], tag_match="all"
    """
    client = await _get_http_client()
    token = _get_token()

    params: dict[str, Any] = {
        "limit": limit,
        "offset": offset,
        "tag_match": tag_match,
        "sort_by": sort_by,
        "sort_order": sort_order,
    }
    if query:
        params["q"] = query
    if tags:
        params["tags"] = tags

    try:
        return await api_get(client, "/notes/", token, params)
    except httpx.HTTPStatusError as e:
        _handle_api_error(e, "searching notes")
        raise
    except httpx.RequestError as e:
        raise ToolError(f"API unavailable: {e}")
```

### Testing Strategy

**File:** `backend/tests/mcp_server/test_tools.py`

Add tests following the exact pattern of bookmark tests:

```python
@pytest.mark.asyncio
async def test__search_notes__basic(
    mock_api,
    mcp_client: Client,
    sample_note_list: dict[str, Any],
) -> None:
    """Test basic note search."""
    mock_api.get("/notes/").mock(
        return_value=Response(200, json=sample_note_list),
    )

    result = await mcp_client.call_tool("search_notes", {})

    assert result.data["total"] == 1
    assert len(result.data["items"]) == 1


@pytest.mark.asyncio
async def test__search_notes__with_query(
    mock_api,
    mcp_client: Client,
    sample_note_list: dict[str, Any],
) -> None:
    """Test note search with query parameter."""
    mock_api.get("/notes/").mock(
        return_value=Response(200, json=sample_note_list),
    )

    await mcp_client.call_tool("search_notes", {"query": "meeting"})

    assert "q" in str(mock_api.calls[0].request.url)


@pytest.mark.asyncio
async def test__search_notes__with_tags(
    mock_api,
    mcp_client: Client,
    sample_note_list: dict[str, Any],
) -> None:
    """Test note search with tag filtering."""
    mock_api.get("/notes/").mock(
        return_value=Response(200, json=sample_note_list),
    )

    await mcp_client.call_tool(
        "search_notes",
        {"tags": ["work", "important"], "tag_match": "any"},
    )

    request_url = str(mock_api.calls[0].request.url)
    assert "tags" in request_url
    assert "tag_match=any" in request_url


@pytest.mark.asyncio
async def test__search_notes__api_unavailable(mock_api, mcp_client: Client) -> None:
    """Test network error handling for note search."""
    mock_api.get("/notes/").mock(side_effect=httpx.ConnectError("Connection refused"))

    result = await mcp_client.call_tool("search_notes", {}, raise_on_error=False)

    assert result.is_error
    assert "unavailable" in result.content[0].text.lower()
```

### Risk Factors

- Ensure the `/notes/` endpoint query parameters match what the MCP tool sends (check `sort_by` options match the backend)

---

## Milestone 2: `get_note` and `create_note` Tools

### Goal

Add MCP tools for getting and creating individual notes.

### Dependencies

Milestone 1 (test fixtures)

### Success Criteria

- [ ] `get_note` tool implemented
- [ ] `create_note` tool implemented
- [ ] All tests pass
- [ ] `make linting` passes

### Key Changes

#### 1. Add `get_note` Tool

**File:** `backend/src/mcp_server/server.py`

Add after `get_bookmark`:

```python
@mcp.tool(
    description="Get the full details of a specific note including content",
    annotations={"readOnlyHint": True},
)
async def get_note(
    note_id: Annotated[int, Field(description="The ID of the note to retrieve")],
) -> dict[str, Any]:
    """Get a note by ID. Returns full details including markdown content."""
    client = await _get_http_client()
    token = _get_token()

    try:
        return await api_get(client, f"/notes/{note_id}", token)
    except httpx.HTTPStatusError as e:
        if e.response.status_code == 404:
            raise ToolError(f"Note with ID {note_id} not found")
        _handle_api_error(e, f"getting note {note_id}")
        raise
    except httpx.RequestError as e:
        raise ToolError(f"API unavailable: {e}")
```

#### 2. Add `create_note` Tool

**File:** `backend/src/mcp_server/server.py`

Add after `create_bookmark`:

```python
@mcp.tool(
    description="Create a new note.",
    annotations={"readOnlyHint": False},
)
async def create_note(
    title: Annotated[str, Field(description="The note title (required)")],
    description: Annotated[str | None, Field(description="Short description/summary")] = None,
    content: Annotated[str | None, Field(description="Markdown content of the note")] = None,
    tags: Annotated[
        list[str] | None,
        Field(description="Tags to assign (lowercase with hyphens, e.g., 'meeting-notes')"),
    ] = None,
) -> dict[str, Any]:
    """Create a new note with optional markdown content."""
    client = await _get_http_client()
    token = _get_token()

    payload: dict[str, Any] = {"title": title}
    if description is not None:
        payload["description"] = description
    if content is not None:
        payload["content"] = content
    if tags is not None:
        payload["tags"] = tags

    try:
        return await api_post(client, "/notes/", token, payload)
    except httpx.HTTPStatusError as e:
        _handle_api_error(e, "creating note")
        raise
    except httpx.RequestError as e:
        raise ToolError(f"API unavailable: {e}")
```

### Testing Strategy

**File:** `backend/tests/mcp_server/test_tools.py`

```python
@pytest.mark.asyncio
async def test__get_note__success(
    mock_api,
    mcp_client: Client,
    sample_note: dict[str, Any],
) -> None:
    """Test getting a note by ID."""
    mock_api.get("/notes/1").mock(
        return_value=Response(200, json=sample_note),
    )

    result = await mcp_client.call_tool("get_note", {"note_id": 1})

    assert result.data["id"] == 1
    assert result.data["title"] == "Test Note"
    assert result.data["content"] is not None


@pytest.mark.asyncio
async def test__get_note__not_found(mock_api, mcp_client: Client) -> None:
    """Test 404 error handling for notes."""
    mock_api.get("/notes/999").mock(
        return_value=Response(404, json={"detail": "Not found"}),
    )

    result = await mcp_client.call_tool(
        "get_note", {"note_id": 999}, raise_on_error=False,
    )

    assert result.is_error
    assert "not found" in result.content[0].text.lower()


@pytest.mark.asyncio
async def test__create_note__success(
    mock_api,
    mcp_client: Client,
    sample_note: dict[str, Any],
) -> None:
    """Test creating a note."""
    mock_api.post("/notes/").mock(
        return_value=Response(201, json=sample_note),
    )

    result = await mcp_client.call_tool(
        "create_note",
        {
            "title": "Test Note",
            "content": "# Markdown Content",
            "tags": ["test"],
        },
    )

    assert result.data["id"] == 1
    assert result.data["title"] == "Test Note"


@pytest.mark.asyncio
async def test__create_note__minimal(
    mock_api,
    mcp_client: Client,
    sample_note: dict[str, Any],
) -> None:
    """Test creating a note with only required title."""
    mock_api.post("/notes/").mock(
        return_value=Response(201, json=sample_note),
    )

    result = await mcp_client.call_tool(
        "create_note",
        {"title": "Quick Note"},
    )

    assert result.data["id"] == 1


@pytest.mark.asyncio
async def test__create_note__api_error(mock_api, mcp_client: Client) -> None:
    """Test API error handling for note creation."""
    mock_api.post("/notes/").mock(
        return_value=Response(400, json={"detail": "Title is required"}),
    )

    result = await mcp_client.call_tool(
        "create_note", {"title": ""}, raise_on_error=False,
    )

    assert result.is_error
```

### Risk Factors

- None - straightforward implementation following existing patterns

---

## Milestone 3: `search_all_content` Unified Search Tool

### Goal

Add a unified search tool that searches across both bookmarks and notes.

### Dependencies

Milestone 1 (test fixtures)

### Success Criteria

- [ ] `sample_content_list` fixture added
- [ ] `search_all_content` tool implemented
- [ ] All tests pass
- [ ] `make linting` passes

### Key Changes

#### 1. Add Content List Fixture

**File:** `backend/tests/mcp_server/conftest.py`

```python
@pytest.fixture
def sample_content_list(sample_bookmark: dict[str, Any], sample_note: dict[str, Any]) -> dict[str, Any]:
    """Sample unified content search response."""
    bookmark_item = {
        "type": "bookmark",
        "id": sample_bookmark["id"],
        "title": sample_bookmark["title"],
        "description": sample_bookmark["description"],
        "tags": sample_bookmark["tags"],
        "created_at": sample_bookmark["created_at"],
        "updated_at": sample_bookmark["updated_at"],
        "last_used_at": sample_bookmark["last_used_at"],
        "deleted_at": sample_bookmark["deleted_at"],
        "archived_at": sample_bookmark["archived_at"],
        "url": sample_bookmark["url"],
        "version": None,
    }
    note_item = {
        "type": "note",
        "id": sample_note["id"],
        "title": sample_note["title"],
        "description": sample_note["description"],
        "tags": sample_note["tags"],
        "created_at": sample_note["created_at"],
        "updated_at": sample_note["updated_at"],
        "last_used_at": sample_note["last_used_at"],
        "deleted_at": sample_note["deleted_at"],
        "archived_at": sample_note["archived_at"],
        "url": None,
        "version": sample_note["version"],
    }
    return {
        "items": [bookmark_item, note_item],
        "total": 2,
        "offset": 0,
        "limit": 50,
        "has_more": False,
    }
```

#### 2. Add `search_all_content` Tool

**File:** `backend/src/mcp_server/server.py`

Add after `search_notes`:

```python
@mcp.tool(
    description=(
        "Search across all content types (bookmarks and notes) with unified results. "
        "Returns active content only. Each item has a 'type' field."
    ),
    annotations={"readOnlyHint": True},
)
async def search_all_content(
    query: Annotated[
        str | None,
        Field(description="Text to search in title, description, URL (bookmarks), and content"),
    ] = None,
    tags: Annotated[list[str] | None, Field(description="Filter by tags")] = None,
    tag_match: Annotated[
        Literal["all", "any"],
        Field(description="Tag matching: 'all' requires ALL tags, 'any' requires ANY tag"),
    ] = "all",
    sort_by: Annotated[
        Literal["created_at", "updated_at", "last_used_at", "title"],
        Field(description="Field to sort by"),
    ] = "created_at",
    sort_order: Annotated[Literal["asc", "desc"], Field(description="Sort direction")] = "desc",
    limit: Annotated[int, Field(ge=1, le=100, description="Maximum results to return")] = 50,
    offset: Annotated[
        int, Field(ge=0, description="Number of results to skip for pagination"),
    ] = 0,
) -> dict[str, Any]:
    """
    Unified search across bookmarks and notes.

    Returns items with a 'type' field ("bookmark" or "note").
    Bookmark items include 'url', note items include 'version'.

    Examples:
    - Search all content: query="python"
    - Filter by tags across all types: tags=["work"]
    """
    client = await _get_http_client()
    token = _get_token()

    params: dict[str, Any] = {
        "limit": limit,
        "offset": offset,
        "tag_match": tag_match,
        "sort_by": sort_by,
        "sort_order": sort_order,
    }
    if query:
        params["q"] = query
    if tags:
        params["tags"] = tags

    try:
        return await api_get(client, "/content/", token, params)
    except httpx.HTTPStatusError as e:
        _handle_api_error(e, "searching content")
        raise
    except httpx.RequestError as e:
        raise ToolError(f"API unavailable: {e}")
```

### Testing Strategy

**File:** `backend/tests/mcp_server/test_tools.py`

```python
@pytest.mark.asyncio
async def test__search_all_content__basic(
    mock_api,
    mcp_client: Client,
    sample_content_list: dict[str, Any],
) -> None:
    """Test unified content search."""
    mock_api.get("/content/").mock(
        return_value=Response(200, json=sample_content_list),
    )

    result = await mcp_client.call_tool("search_all_content", {})

    assert result.data["total"] == 2
    assert len(result.data["items"]) == 2
    types = [item["type"] for item in result.data["items"]]
    assert "bookmark" in types
    assert "note" in types


@pytest.mark.asyncio
async def test__search_all_content__with_query(
    mock_api,
    mcp_client: Client,
    sample_content_list: dict[str, Any],
) -> None:
    """Test unified search with query parameter."""
    mock_api.get("/content/").mock(
        return_value=Response(200, json=sample_content_list),
    )

    await mcp_client.call_tool("search_all_content", {"query": "python"})

    assert "q" in str(mock_api.calls[0].request.url)


@pytest.mark.asyncio
async def test__search_all_content__api_unavailable(mock_api, mcp_client: Client) -> None:
    """Test network error handling for unified search."""
    mock_api.get("/content/").mock(side_effect=httpx.ConnectError("Connection refused"))

    result = await mcp_client.call_tool("search_all_content", {}, raise_on_error=False)

    assert result.is_error
    assert "unavailable" in result.content[0].text.lower()
```

### Risk Factors

- The `/content/` endpoint doesn't expose a `content_types` query parameter. The tool searches all types. If type filtering is needed in the future, the endpoint would need to be updated.

---

## Milestone 4: Update MCP Server Instructions

### Goal

Update the MCP server's instructions string to document all available tools.

### Dependencies

Milestones 1-3

### Success Criteria

- [ ] Instructions updated with all 8 tools
- [ ] Example workflows include notes
- [ ] MCP server starts successfully
- [ ] All tests pass

### Key Changes

**File:** `backend/src/mcp_server/server.py`

Replace the `instructions` parameter in the `FastMCP` constructor (lines 15-41):

```python
mcp = FastMCP(
    name="Bookmarks MCP Server",
    instructions="""
A personal content manager for saving and organizing bookmarks and notes.
Supports full-text search, tagging, and markdown notes.

Available tools:

**Bookmarks:**
- `search_bookmarks`: Search bookmarks by text query and/or filter by tags
- `get_bookmark`: Get full details of a specific bookmark by ID
- `create_bookmark`: Save a new URL (metadata auto-fetched if not provided)

**Notes:**
- `search_notes`: Search notes by text query and/or filter by tags
- `get_note`: Get full details of a specific note by ID (includes content)
- `create_note`: Create a new note with markdown content

**Unified:**
- `search_all_content`: Search across both bookmarks and notes in one query
- `list_tags`: Get all tags with usage counts (shared across content types)

Example workflows:

1. "Show me my reading list" or "What articles do I have saved?"
   - First call `list_tags()` to discover the user's tag taxonomy
   - Identify relevant tags (e.g., `reading-list`, `articles`, `to-read`)
   - Call `search_bookmarks(tags=["reading-list"])` to filter by that tag

2. "Find my Python tutorials"
   - Call `search_bookmarks(query="python tutorial")` for text search, or
   - Call `list_tags()` first, then `search_bookmarks(tags=["python", "tutorial"])`

3. "Save this article: <url>"
   - Call `create_bookmark(url="<url>", tags=["articles"])`
   - Title/description are auto-fetched if not provided

4. "What notes do I have about the project?"
   - Call `search_notes(query="project")` for text search
   - Or filter by tag: `search_notes(tags=["work"])`

5. "Create a meeting note"
   - Call `create_note(title="Meeting Notes - Dec 28", content="## Attendees\\n- ...", tags=["meeting"])`

6. "Search everything for Python content"
   - Call `search_all_content(query="python")` to search both bookmarks and notes

Tags are lowercase with hyphens (e.g., `machine-learning`, `to-read`).
""".strip(),
)
```

### Testing Strategy

- Run `make mcp-server` and verify it starts without errors
- Run existing tests to ensure nothing broke
- Optionally test with an MCP client to verify tool discovery

### Risk Factors

- None - documentation-only change

---

## Summary

| Milestone | Description | New Tools | New Tests |
|-----------|-------------|-----------|-----------|
| 1 | Test fixtures + `search_notes` | 1 | 4 |
| 2 | `get_note` + `create_note` | 2 | 5 |
| 3 | `search_all_content` | 1 | 3 |
| 4 | Update instructions | 0 | 0 |

**Total: 4 new tools, 12 new tests**

---

## Implementation Notes

### File Locations

- MCP Server: `backend/src/mcp_server/server.py`
- Test Fixtures: `backend/tests/mcp_server/conftest.py`
- Tool Tests: `backend/tests/mcp_server/test_tools.py`

### Commands to Run

After each milestone:
```bash
make linting
make unit_tests
```

### Patterns to Follow

- All tools follow the same pattern as existing `search_bookmarks`, `get_bookmark`, `create_bookmark`
- All tests follow the same pattern as existing bookmark tool tests
- Use `respx` for mocking HTTP responses in tests
- Use `raise_on_error=False` when testing error conditions

### Important: Do Not Modify

- Do not change the existing bookmark tools
- Do not modify the backend API endpoints
- Do not add new API endpoints (use existing `/notes/` and `/content/` endpoints)
