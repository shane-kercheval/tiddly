# Implementation Plan: DEV Tier for Local Development

## Problem

Running evals, performance benchmarks, and profiling scripts requires temporarily editing `backend/src/core/tier_limits.py` to increase FREE tier limits, then manually reverting. This is tedious and risky (forgetting to revert commits inflated limits to production).

Three docs explicitly instruct this workaround:
- `performance/api/README.md` (lines 64-80)
- `performance/profiling/README.md` (lines 79-85)
- `performance/performance_prompt.md` (lines 13-22, 412-418)

## Solution

Add a `Tier.DEV` enum value with very high limits. Resolve DEV tier at runtime when `settings.dev_mode=true`, without persisting it to the database. The dev user's stored `tier` column remains `"free"` — the override happens at the two consumption points where limits are looked up.

This follows the established dev-mode pattern in the codebase:
- `_apply_rate_limit()` (auth.py:334): `if settings.dev_mode: return`
- `_check_consent()`: skipped in dev mode
- Authentication: bypassed entirely in dev mode

## Design Decision: Runtime Override vs Persisted Tier

We chose **runtime override** (check `settings.dev_mode` at limit resolution) over **persisting `tier="dev"` on the user record** because:

1. **DEV tier is an environment behavior, not a user attribute.** The user isn't "on the dev tier" — the environment is in dev mode. This is the same reason rate limiting checks `settings.dev_mode` rather than storing a flag on the user.
2. **Avoids `User` vs `CachedUser` complexity.** `get_or_create_user()` returns `User | CachedUser`. Mutating `.tier` on a `CachedUser` (plain dataclass) wouldn't persist to DB or update cache. The persisted approach would require handling cache invalidation and type-checking — unnecessary complexity.
3. **No database writes.** The `users` table is never modified. No cache invalidation needed.

## Security Analysis

- **No production exposure risk**: The runtime check uses `settings.dev_mode`, which the config system prevents from being enabled with non-localhost `DATABASE_URL`
- **`Tier.DEV` in production DB**: If a production user somehow had `tier="dev"` in the database (e.g., manual DB edit), `get_tier_safely("dev")` would return `Tier.DEV`. However, this requires direct database write access, at which point an attacker can do far worse. The DEV tier entry in `TIER_LIMITS` includes a comment noting it's only used in dev mode.
- **Multi-tenancy unchanged**: Data isolation via `user_id` is unaffected
- **Backwards compatible**: New tier doesn't change FREE tier behavior

## Test Impact Analysis

- All tests run with `VITE_DEV_MODE=true` (set in `conftest.py` line 59)
- `get_current_limits()` gains a `settings.dev_mode` check, so it will return DEV limits in tests by default
- **Tests that will break and need updating:**
  - `test__get_my_limits__returns_free_tier_limits` (test_users.py:71): Hardcodes `data["tier"] == "free"` and `data["max_bookmarks"] == 100`. Will now get DEV tier values. Must be updated to expect DEV tier values.
  - `test__get_my_limits__uses_low_limits_fixture` (test_users.py:135): Uses `low_limits` fixture which patches only `Tier.FREE` in `TIER_LIMITS`. Since `get_my_limits()` will resolve to `Tier.DEV` in dev mode, the `low_limits` patch on `Tier.FREE` won't apply. The `low_limits` fixture needs to also patch `Tier.DEV`, or `get_my_limits` needs the same `settings.dev_mode` check so `low_limits` can override it.
- **Tests unaffected:**
  - Service-level tests using `default_limits` / `low_limits` fixtures: These pass explicit `TierLimits` to service methods, bypassing the dependency injection path
  - `rate_limit_client` fixture: Already patches around dev mode
  - `test_tier_limits.py`: Tests the enum/dict directly, not the dependency

## Cleanup Task Impact

`cleanup.py` iterates `TIER_LIMITS.items()` to batch-delete old history by tier. Adding `Tier.DEV` to the dict means the cleanup task will also query for users with `tier="dev"`. Since no users will have this tier stored in the database, the query returns zero rows and deletes nothing. No-op in practice.

---

## Milestone 1: Add DEV Tier with Runtime Resolution

### Goal & Outcome

Add `Tier.DEV` with high limits, resolved at runtime when dev mode is active. After this milestone:

- `Tier.DEV` exists as a valid tier enum value
- `TIER_LIMITS[Tier.DEV]` returns very high limits
- `get_current_limits()` returns DEV limits when `settings.dev_mode=true`
- `/users/me/limits` returns DEV limits when `settings.dev_mode=true`
- The dev user's `tier` column in the database is **unchanged** (stays `"free"`)
- `get_or_create_dev_user()` is **unchanged**
- Evals, benchmarks, and profiling scripts work without manual limit patching
- All existing tests pass (with updates to tests that hardcode FREE tier expectations)

### Implementation Outline

**1. `backend/src/core/tier_limits.py`** — Add DEV tier enum and limits

Add `DEV = "dev"` to the `Tier` enum. Add a `Tier.DEV` entry to `TIER_LIMITS` with very high values (e.g., `999_999` for item counts/rates, `10_000_000` for content lengths, `9999` for retention days). Include a comment noting this tier is only used at runtime in dev mode, not persisted to the database.

```python
class Tier(StrEnum):
    FREE = "free"
    DEV = "dev"
    # PRO = "pro"  # future
```

```python
TIER_LIMITS: dict[Tier, TierLimits] = {
    Tier.FREE: TierLimits(...),  # unchanged
    # DEV tier: resolved at runtime when settings.dev_mode=true.
    # Not persisted to the database. Effectively unlimited for local
    # development, evals, and performance testing.
    Tier.DEV: TierLimits(
        max_bookmarks=999_999,
        max_notes=999_999,
        max_prompts=999_999,
        # ... all fields set very high
    ),
}
```

**2. `backend/src/api/dependencies.py`** — Resolve DEV tier at runtime in `get_current_limits()`

Add a `settings` dependency and return DEV limits when in dev mode. This is the primary consumption point — all service routes use `Depends(get_current_limits)`.

```python
from core.config import Settings, get_settings
from core.tier_limits import Tier, TierLimits, get_tier_limits, get_tier_safely

def get_current_limits(
    current_user: CachedUser = Depends(get_current_user),
    settings: Settings = Depends(get_settings),
) -> TierLimits:
    if settings.dev_mode:
        return get_tier_limits(Tier.DEV)
    tier = get_tier_safely(current_user.tier)
    return get_tier_limits(tier)
```

**3. `backend/src/api/routers/users.py`** — Same runtime check in `get_my_limits()`

This endpoint resolves tier directly (not via `get_current_limits`), so it needs the same check.

```python
from core.config import Settings, get_settings

@router.get("/me/limits", response_model=UserLimitsResponse)
async def get_my_limits(
    current_user: User = Depends(get_current_user),
    settings: Settings = Depends(get_settings),
) -> UserLimitsResponse:
    if settings.dev_mode:
        tier = Tier.DEV
    else:
        tier = get_tier_safely(current_user.tier)
    limits = get_tier_limits(tier)
    return UserLimitsResponse(
        tier=tier.value,
        **asdict(limits),
    )
```

**4. Update existing tests** (`backend/tests/api/test_users.py`)

- `test__get_my_limits__returns_free_tier_limits` — Rename to `test__get_my_limits__returns_dev_tier_limits_in_dev_mode` and update expected values to match DEV tier (since tests run with `VITE_DEV_MODE=true`)
- `test__get_my_limits__uses_low_limits_fixture` — The `low_limits` fixture patches `Tier.FREE` in the `TIER_LIMITS` dict, but in dev mode the endpoint now resolves `Tier.DEV`. Update the fixture to also patch `Tier.DEV`:

```python
# In conftest.py, update low_limits fixture:
@pytest.fixture
def low_limits() -> Generator[TierLimits]:
    with patch.dict(
        "core.tier_limits.TIER_LIMITS",
        {Tier.FREE: LOW_TIER_LIMITS, Tier.DEV: LOW_TIER_LIMITS},
    ):
        yield LOW_TIER_LIMITS
```

**5. Update documentation**

- `performance/api/README.md`: Remove the "Tier Limits" section (lines 64-80). Replace with a note that dev mode automatically uses unlimited limits.
- `performance/profiling/README.md`: Remove the "Tier Limits" section (lines 79-85). Same replacement.
- `performance/performance_prompt.md`: Remove the tier limit instructions (lines 13-22) and the revert step (lines 412-418). Replace with a note that dev mode handles this automatically.

### Testing Strategy

**Unit tests** (`backend/tests/core/test_tier_limits.py`):

- `test__tier_dev__has_expected_value` — `Tier.DEV == "dev"` and `Tier.DEV.value == "dev"`
- `test__get_tier_limits__returns_dev_limits` — `get_tier_limits(Tier.DEV)` returns a `TierLimits` with the expected high values
- `test__dev_tier__all_limits_higher_than_free` — Every field in DEV limits >= corresponding FREE field (iterate `dataclasses.fields()` to compare, ensures no accidental regression)
- `test__get_tier_safely__dev_value` — `get_tier_safely("dev")` returns `Tier.DEV`

**Dependency tests** (`backend/tests/api/test_dependencies.py` or inline in test_users.py):

- `test__get_current_limits__returns_dev_limits_in_dev_mode` — When `settings.dev_mode=true`, returns `Tier.DEV` limits regardless of user's stored tier
- `test__get_current_limits__returns_user_tier_limits_when_not_dev_mode` — When `settings.dev_mode=false`, resolves from `current_user.tier` as before

**Endpoint tests** (`backend/tests/api/test_users.py`):

- Update `test__get_my_limits__returns_free_tier_limits` → expects DEV tier values (tests run in dev mode)
- Update `test__get_my_limits__uses_low_limits_fixture` → works with updated fixture that patches both tiers
- `test__get_my_limits__returns_free_tier_when_not_dev_mode` — Patch `settings.dev_mode=false` and verify FREE tier is returned (confirms the runtime check works correctly in the non-dev path)

**Verify all existing tests pass**: Run `make tests` after all changes.
