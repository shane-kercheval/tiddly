# Public ID Implementation Plan

## Overview

Add a `public_id` column to Bookmarks, Notes, and Prompts to prevent information leakage from sequential integer IDs. The public ID will be exposed in APIs while internal integer IDs remain for database efficiency (foreign keys, joins).

### Problem

Current auto-increment integer IDs leak information:
- Competitors can infer total record counts ("my note is ID 50,000")
- Growth rates can be estimated by creating accounts over time
- Sequential IDs provide enumeration surface for attackers

### Why Not ULID-Only Primary Keys?

Using ULID as the sole primary key would be simpler (one ID everywhere), but we chose dual IDs for:

- **Smaller indexes**: Integer PKs are 4-8 bytes vs 26 bytes for ULID strings. With multiple indexes per table, this adds up (e.g., ~90 MB difference per 1M rows with 3 indexes).
- **Faster joins**: Integer comparison is a single CPU instruction; string comparison requires byte-by-byte evaluation. Join-heavy queries can be 10-20% slower with string keys.
- **Lower memory pressure**: Smaller indexes fit better in RAM, reducing cache misses and disk I/O.
- **Foreign key efficiency**: All FK references (bookmark→user, note→tags, etc.) use compact integers internally.

The overhead of ULID-only PKs is small for most apps, but since we don't need cross-shard references (user-sharded architecture keeps all related data together), we get the best of both worlds: external security + internal efficiency.

### Solution: Dual ID Strategy

Add a ULID-based `public_id` column:
- **Internal `id`**: Integer primary key for foreign keys, joins, indexes
- **External `public_id`**: ULID string exposed in APIs

**Why ULID over UUID?**
- Time-sortable (unlike UUIDv4)
- URL-friendly (26 chars, base32)
- No information leakage about volume
- Lexicographically sortable
- **Sequential insert performance**: Time-ordering means new records append to index end, avoiding the random I/O and B-tree page splits that plague UUIDv4

### Key Design Decisions

1. **ULID generation**: Generate in Python at model instantiation, not database-side
2. **API field name**: Keep `id` as the API field name (not `public_id`). Clients continue using `bookmark.id` - only the type changes from `int` to `str`.
3. **Internal column naming**: Database column is `public_id` to distinguish from the integer primary key `id`
4. **Internal usage**: Keep integer PK for all internal operations (FKs, service layer joins)
5. **Minimal breaking change**: Only the type changes (`int` → `str`), not the field names. Clients using `/bookmarks/${bookmark.id}` continue working.

---

## Milestone 1: Add ULID Library and Base Model Changes

### Goal
Add ULID generation capability and create a mixin for the `public_id` column that can be shared across models.

### Success Criteria
- `python-ulid` library installed
- `PublicIdMixin` created with `public_id` column
- ULID auto-generates on model instantiation
- Unit tests verify ULID generation and format

### Key Changes

**1. Add dependency to `pyproject.toml`:**

```bash
uv add python-ulid
```

**2. Create `PublicIdMixin` in `backend/src/models/base.py`:**

```python
from ulid import ULID

class PublicIdMixin:
    """Mixin that adds a public_id column for external exposure."""

    public_id: Mapped[str] = mapped_column(
        String(26),
        unique=True,
        index=True,
        nullable=False,
        default=lambda: str(ULID()),
    )
```

**Documentation**: Read python-ulid docs at https://python-ulid.readthedocs.io/

### Testing Strategy
- Test ULID is auto-generated when not provided
- Test ULID format is valid (26 chars, base32)
- Test ULID uniqueness constraint works
- Test custom ULID can be provided (for migration)

### Dependencies
None - this is the foundation.

### Risk Factors
- Ensure `default=lambda` works correctly with SQLAlchemy (not evaluated once at class definition)

---

## Milestone 2: Add `public_id` to Bookmark Model

### Goal
Add `public_id` column to Bookmark model with database migration.

### Success Criteria
- Bookmark model includes `PublicIdMixin`
- Alembic migration adds column with unique constraint
- Existing bookmarks get ULIDs generated (based on `created_at` if confirmed)
- All existing Bookmark tests pass

### Key Changes

**1. Update `backend/src/models/bookmark.py`:**

```python
from models.base import ArchivableMixin, Base, TimestampMixin, PublicIdMixin

class Bookmark(Base, TimestampMixin, ArchivableMixin, PublicIdMixin):
    # ... existing fields ...
```

**2. Create Alembic migration:**

```bash
make migration message="add public_id to bookmarks"
```

The migration should:
1. Add `public_id` column as nullable initially
2. Generate ULIDs for existing rows (use `created_at` timestamp if confirmed)
3. Set column to NOT NULL
4. Add unique index

**Migration pattern for existing data:**

```python
from ulid import ULID
from datetime import datetime

def upgrade():
    # Add nullable column first
    op.add_column('bookmarks', sa.Column('public_id', sa.String(26), nullable=True))

    # Generate ULIDs for existing rows
    connection = op.get_bind()
    bookmarks = connection.execute(sa.text("SELECT id, created_at FROM bookmarks"))
    for row in bookmarks:
        # Generate ULID from created_at timestamp for sort consistency
        ulid = ULID.from_datetime(row.created_at)
        connection.execute(
            sa.text("UPDATE bookmarks SET public_id = :public_id WHERE id = :id"),
            {"public_id": str(ulid), "id": row.id}
        )

    # Make non-nullable and add index
    op.alter_column('bookmarks', 'public_id', nullable=False)
    op.create_index('ix_bookmarks_public_id', 'bookmarks', ['public_id'], unique=True)
```

### Testing Strategy

**Unit tests:**
- Test new bookmark gets auto-generated `public_id`
- Test unique constraint prevents duplicate `public_id`
- Test existing bookmark tests still pass

**Pre-production migration testing:**

The agent should run the migration on local dev environments, but after successfully implementing and testing the migration code, they should notify the human to run the following steps to verify correctness before production deployment:

Before running on production, test against a copy of production data:

```bash
# 1. Set environment variables
export PROD_DATABASE_URL="postgresql://postgres:..."
export BACKUP_DATABASE_URL="postgresql://postgres:..."

# 2. Copy production database to backup
PGSSLMODE=require pg_dump --dbname="$PROD_DATABASE_URL" -F c \
  | PGSSLMODE=require pg_restore --clean --if-exists --no-owner --no-privileges \
    --dbname="$BACKUP_DATABASE_URL"

# 3. Check for duplicate timestamps that could cause ULID collisions
PGSSLMODE=require psql "$BACKUP_DATABASE_URL" -c \
  "SELECT created_at, COUNT(*) FROM bookmarks GROUP BY created_at HAVING COUNT(*) > 1;"

# 4. Run migration against backup
DATABASE_URL="$BACKUP_DATABASE_URL" uv run alembic upgrade head

# 5. Verify all rows got ULIDs
PGSSLMODE=require psql "$BACKUP_DATABASE_URL" -c \
  "SELECT COUNT(*) FROM bookmarks WHERE public_id IS NULL;"
# Should return 0

# 6. Verify no duplicate ULIDs
PGSSLMODE=require psql "$BACKUP_DATABASE_URL" -c \
  "SELECT public_id, COUNT(*) FROM bookmarks GROUP BY public_id HAVING COUNT(*) > 1;"
# Should return 0 rows

# 7. Test rollback works
DATABASE_URL="$BACKUP_DATABASE_URL" uv run alembic downgrade -1
```

### Dependencies
Milestone 1 (PublicIdMixin must exist)

### Risk Factors
- Migration on large tables may be slow - consider batching for tables with 100k+ rows
- Ensure `ULID.from_datetime()` handles timezone-aware datetimes correctly
- Duplicate `created_at` timestamps could cause ULID collisions (check step 3 above)

---

## Milestone 3: Update Bookmark Schemas and Service Layer

### Goal
Change `id` field from integer to ULID string in API responses and lookups. Field names remain unchanged but will use public_id internally.

### Success Criteria
- `BookmarkResponse` schema returns `id: str` (ULID) instead of `id: int`
- `BookmarkListItem` schema returns `id: str` (ULID) instead of `id: int`
- Service layer lookups use `public_id` column internally
- Router parameters change from `int` to `str`
- Clients using `bookmark.id` continue working (just different value format)

### Key Changes

**1. Update `backend/src/schemas/bookmark.py`:**

Change `id` field type and update the existing `model_validator` to map `public_id` → `id`:

```python
class BookmarkListItem(BaseModel):
    model_config = ConfigDict(from_attributes=True)

    id: str  # Changed from int - now ULID string
    # ... rest of fields unchanged ...

    @model_validator(mode="before")
    @classmethod
    def extract_tag_names(cls, data: Any) -> Any:
        if hasattr(data, "__dict__"):
            data_dict = {}
            for key in [
                "url", "title", "description", "summary",
                "created_at", "updated_at", "last_used_at",
                "deleted_at", "archived_at", "content",
            ]:
                if hasattr(data, key):
                    data_dict[key] = getattr(data, key)

            # Map public_id column to id field for API response
            data_dict["id"] = getattr(data, "public_id")

            # ... rest of existing tag extraction logic unchanged ...
```

The existing `model_validator` already transforms SQLAlchemy models to dicts - just add the `public_id` → `id` mapping there.

**2. Update `backend/src/services/bookmark_service.py`:**

Update lookup functions to use `public_id` column:

```python
async def get_bookmark(
    session: AsyncSession,
    user_id: int,
    bookmark_id: str,  # Now a ULID string
    include_deleted: bool = False,
    include_archived: bool = True,
) -> Bookmark | None:
    """Get a bookmark by its public ID for a user."""
    query = select(Bookmark).where(
        Bookmark.user_id == user_id,
        Bookmark.public_id == bookmark_id,  # Query by public_id column
    )
    # ... existing filters ...
```

**3. Update `backend/src/api/routers/bookmarks.py`:**

Change path parameter types from `int` to `str`:

```python
@router.get("/{bookmark_id}")
async def get_bookmark(
    bookmark_id: str,  # Changed from int
    # ...
):
    bookmark = await bookmark_service.get_bookmark(
        session, user.id, bookmark_id  # Now passes ULID string
    )
```

### Testing Strategy

**Update existing tests:**
```bash
# Find all tests that reference bookmark IDs as integers
grep -rn "bookmark.id" backend/tests/
grep -rn "bookmark_id" backend/tests/
grep -rn '"id":' backend/tests/  # JSON response assertions
```

Common patterns to update:
- `assert response.json()["id"] == 1` → `assert isinstance(response.json()["id"], str)`
- `bookmark_id: int` in test function signatures → `bookmark_id: str`
- Fixtures that return integer IDs → return ULID strings

**New tests:**
- Test API returns `id` field with ULID string value
- Test GET `/bookmarks/{ulid}` works correctly
- Test 404 returned for invalid/nonexistent ULID
- Test 404 returned for malformed ULID (not 26 chars, invalid characters)

### Dependencies
Milestone 2 (column must exist in database)

### Risk Factors
- Must update ALL router endpoints that reference bookmarks by ID
- Schema mapping from `public_id` column to `id` field needs care

---

## Milestone 4: Add `public_id` to Note Model

### Goal
Repeat Milestone 2 pattern for Notes.

### Success Criteria
- Note model includes `PublicIdMixin`
- Migration adds column with ULIDs for existing notes
- All existing Note tests pass

### Key Changes

**1. Update `backend/src/models/note.py`:**

```python
from models.base import ArchivableMixin, Base, TimestampMixin, PublicIdMixin

class Note(Base, TimestampMixin, ArchivableMixin, PublicIdMixin):
    # ... existing fields ...
```

**2. Create migration** (same pattern as Milestone 2)

### Testing Strategy
- Same as Milestone 2 but for Notes

### Dependencies
Milestone 1 (PublicIdMixin)

### Risk Factors
- Same as Milestone 2

---

## Milestone 5: Update Note Schemas and Service Layer

### Goal
Repeat Milestone 3 pattern for Notes - change `id` field from integer to ULID string.

### Success Criteria
- Note schemas return `id: str` (ULID)
- Note service/router use `public_id` column for lookups
- Router parameters change from `int` to `str`
- All Note API tests pass

### Key Changes
Same pattern as Milestone 3 but for Notes:
- Update `NoteResponse` and `NoteListItem` schemas: `id: str`
- Update `note_service.py` to query by `public_id` column
- Update `notes.py` router parameter types from `int` to `str`

### Testing Strategy

**Update existing tests:**
```bash
# Find all tests that reference note IDs as integers
grep -rn "note.id" backend/tests/
grep -rn "note_id" backend/tests/
grep -rn '"id":' backend/tests/api/routers/test_notes*.py
```

Same patterns as Milestone 3 - update type assertions and fixtures.

**New tests:**
- Test API returns `id` field with ULID string value
- Test GET `/notes/{ulid}` works correctly
- Test 404 returned for invalid/nonexistent ULID

### Dependencies
Milestone 4

### Risk Factors
- Same as Milestone 3

---

## Milestone 6: Add `public_id` to Prompt Model

### Goal
Repeat pattern for Prompts - add `public_id` column and update schemas/service.

### Success Criteria
- Prompt model includes `PublicIdMixin`
- Migration adds column with ULIDs for existing prompts
- Prompt schemas return `id: str` (ULID)
- Prompt service/router use `public_id` column for lookups
- All Prompt tests pass

### Key Changes
Same pattern as Milestones 2-3 but for Prompts:
- Add `PublicIdMixin` to Prompt model
- Create migration for `public_id` column
- Update `PromptResponse` and `PromptListItem` schemas: `id: str`
- Update `prompt_service.py` to query by `public_id` column
- Update `prompts.py` router parameter types from `int` to `str`

### Testing Strategy

**Update existing tests:**
```bash
# Find all tests that reference prompt IDs as integers
grep -rn "prompt.id" backend/tests/
grep -rn "prompt_id" backend/tests/
grep -rn '"id":' backend/tests/api/routers/test_prompts*.py
```

Same patterns as Milestone 3 - update type assertions and fixtures.

**New tests:**
- Test API returns `id` field with ULID string value
- Test GET `/prompts/{ulid}` works correctly
- Test 404 returned for invalid/nonexistent ULID

### Dependencies
Milestone 1

### Risk Factors
- Same as previous milestones

---

## Milestone 7: Update MCP Servers

### Goal
Update Content MCP server and Prompt MCP server to use ULID strings for `id` parameters.

### Success Criteria
- MCP tools accept `id` parameters as `str` instead of `int`
- MCP server tests pass

### Key Changes

**Minimal changes required** - MCP servers are thin HTTP wrappers with `dict[str, Any]` returns.

**1. Update `backend/src/mcp_server/server.py`:**

Change two parameter type annotations:

```python
# get_bookmark (line ~320)
# Before:
bookmark_id: Annotated[int, Field(description="The ID of the bookmark to retrieve")]
# After:
bookmark_id: Annotated[str, Field(description="The ID of the bookmark to retrieve")]

# get_note (line ~342)
# Before:
note_id: Annotated[int, Field(description="The ID of the note to retrieve")]
# After:
note_id: Annotated[str, Field(description="The ID of the note to retrieve")]
```

**No other changes needed:**
- URL construction (`f"/bookmarks/{bookmark_id}"`) already works with strings
- Search functions don't take IDs as parameters
- Return types are `dict[str, Any]` - loosely typed, handles string IDs automatically
- Create functions return loosely typed dicts

**2. Update `backend/src/prompt_mcp_server/server.py`:**

Same pattern - change `prompt_id` parameter type from `int` to `str`.

### Testing Strategy
- Test `get_bookmark` and `get_note` work with ULID string IDs
- Test 404 returned for invalid/nonexistent ULID
- Verify search results include `id` as string (no code change, just verify)

### Dependencies
Milestones 3, 5, 6 (API endpoints must accept string IDs)

### Risk Factors
- Very low risk - minimal code changes

---

## Milestone 8: Update Frontend

### Goal
Update frontend TypeScript types to expect `id` as string instead of number. Field names stay the same.

### Success Criteria
- TypeScript types use `id: string` instead of `id: number`
- All existing code using `bookmark.id`, `note.id`, etc. continues working
- URL routes continue working (`/bookmarks/${bookmark.id}`)
- All frontend functionality works

### Key Changes

**1. Update `frontend/src/types.ts`:**

```typescript
export interface Bookmark {
  id: string;  // Changed from number - now ULID string
  // ... rest unchanged
}

export interface Note {
  id: string;  // Changed from number
  // ...
}

export interface Prompt {
  id: string;  // Changed from number
  // ...
}
```

**2. Minimal other changes needed:**

Since field names stay the same, most code works as-is:
- `bookmark.id` still works
- `/bookmarks/${bookmark.id}` still works
- API calls still work

Only code doing integer operations on IDs would break (unlikely).

### Testing Strategy
- Run TypeScript compiler to catch type errors
- Test all CRUD operations work
- Test navigation/URLs work correctly
- Run frontend test suite

### Dependencies
All backend milestones complete

### Risk Factors
- Any code comparing IDs as numbers would break (e.g., `id === 123`)
- Search for any numeric ID comparisons or operations

---

## Summary

| Milestone | Component | Scope |
|-----------|-----------|-------|
| 1 | ULID + Mixin | Foundation |
| 2 | Bookmark Model | Database |
| 3 | Bookmark API | Backend |
| 4 | Note Model | Database |
| 5 | Note API | Backend |
| 6 | Prompt Model + API | Database + Backend |
| 7 | MCP Servers | Backend |
| 8 | Frontend | Frontend |

Total: 8 milestones. Each milestone should be reviewed before proceeding to the next.
