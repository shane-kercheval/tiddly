# Notes Feature Implementation Plan

**Date:** 2025-12-26
**Scope:** Add Notes functionality with full CRUD, unified navigation, and MCP integration

---

## Guiding Principles

These principles MUST guide all implementation decisions:

1. **No Legacy Code** - Delete and refactor, never work around. No backwards compatibility hacks.
2. **Single Source of Truth** - No duplicated logic. Extract shared patterns.
3. **Consistent Patterns** - Notes follows identical patterns to Bookmarks, not a bolted-on afterthought.
4. **Thorough Testing** - Every service function, endpoint, and component gets tests. Test edge cases and error conditions.
5. **Clean Abstractions** - Extract shared logic (tags, soft delete, archive) into reusable modules only when duplication emerges.
6. **Gold Standard Architecture** - Our design should be the standard others strive towards.
7. **Ask, Don't Assume** - When requirements are ambiguous, ask for clarification before implementing.

---

## Architecture Decisions

### What We're Building NOW

1. **Note Model** - Similar to Bookmark but without URL, with required title
2. **NoteVersion Table** - Schema only (empty), designed for diff-based history
3. **ContentList Refactor** - Rename BookmarkList, add `content_types` field
4. **Unified Navigation** - New sidebar structure with shared/type-specific sections
5. **Notes UI** - Full-page view/edit (not modal), markdown rendering
6. **Unified Search Endpoint** - `GET /content/search` for cross-type search
7. **MCP Tools** - `search_content` (unified), `get_note`, `create_note`

### What We're Building LATER (Not in this plan)

1. **Version History Logic** - Actually saving diffs and reconstructing versions
2. **Bulk Operations** - Bulk archive/delete
3. **Todos** - Third content type (future expansion)
4. **Tabbed Note Editor** - Multiple notes open simultaneously

### Version History Architecture (Design Now, Implement Later)

We will create the `NoteVersion` table NOW with the correct schema for diff-based storage:

```python
class NoteVersion(Base):
    id: int
    note_id: int (FK -> Note, CASCADE)
    version: int  # Sequential version number
    version_type: str  # "snapshot" | "diff"
    content: Text  # Full content if snapshot, diff if diff
    saved_at: DateTime
```

**Future strategy (not implemented now):**
- Every Nth save (e.g., 10) = full snapshot
- In-between saves = diff only (using diff-match-patch library)
- To reconstruct version X: find nearest prior snapshot, apply diffs forward

The `Note` model will include a `version: int` field (starting at 1) to track current version.

**Version semantics (important for future implementation):**
- `Note.content` is always the **live/current version**
- `Note.version` starts at 1 for new notes
- **Version 1 has NO `NoteVersion` row** - the Note itself is version 1
- When a note is saved (future): create a `NoteVersion` row with the diff, then update `Note.content` and increment `Note.version`
- To get version history: query `NoteVersion` rows for the note, reconstruct by applying diffs

This avoids storing duplicate content for version 1 and keeps the model clean.

---

## API Architecture

### REST Endpoints (Hybrid Approach)

**Type-specific endpoints (for single-type operations):**
- `GET /bookmarks/` - list/search bookmarks (existing)
- `GET /notes/` - list/search notes (new)
- `POST/PATCH/DELETE` for each type

**Unified search endpoint (for cross-type operations):**
- `GET /content/search` - search across types, returns grouped results

**Rationale:**
- Type-specific endpoints follow REST conventions and return homogeneous data
- Unified search powers the "All" view and MCP tool with a single API call
- Service layer shares search logic to avoid duplication

### MCP Tools (Consolidated)

**Final tool list (6 tools):**
- `search_content` - unified search across types (replaces `search_bookmarks`)
- `get_bookmark` - get single bookmark
- `get_note` - get single note
- `create_bookmark` - create bookmark (URL required)
- `create_note` - create note (title required)
- `list_tags` - list all tags (shared)

**Why no separate `search_bookmarks`/`search_notes` tools:**
- Fewer tools = less confusion for AI agents
- `search_content(content_types=["bookmark"])` achieves the same result
- One tool to learn, one behavior pattern

---

## Content Length Limits

- **Bookmarks:** 500KB content limit (existing)
- **Notes:** 2MB content limit (confirmed) - allows for long-form documents

---

## Markdown Rendering

**For viewing (render mode):**
- `react-markdown` - renders markdown to React components
- `remark-gfm` - GitHub Flavored Markdown support (tables, strikethrough, task lists)
- `rehype-sanitize` - XSS protection (required for security)

**For editing:**
- `@uiw/react-codemirror` - React wrapper for CodeMirror 6
- `@codemirror/lang-markdown` - Markdown language support with syntax highlighting

**Rationale:**
- CodeMirror provides syntax highlighting while editing (headers, bold, code blocks, links)
- Better handling of large documents
- Built-in undo/redo, search/replace
- `@uiw/react-codemirror` makes integration simple

**Fallback strategy (development-time decision):**
If CodeMirror introduces unforeseen complexity during implementation (e.g., bundle size issues, mobile compatibility problems, or integration conflicts), we can replace it with a simple `<textarea>` with monospace font. This is a **development-time decision**, not a runtime fallback. The editor component will use either CodeMirror OR textarea, not both.

**npm packages to install:**
```bash
npm install react-markdown remark-gfm rehype-sanitize @uiw/react-codemirror @codemirror/lang-markdown
```

**Basic CodeMirror usage:**
```tsx
import CodeMirror from '@uiw/react-codemirror';
import { markdown } from '@codemirror/lang-markdown';

<CodeMirror
  value={content}
  onChange={(value) => setContent(value)}
  extensions={[markdown()]}
  height="400px"
/>
```

---

## Navigation Structure

The new sidebar structure:

```
Sidebar:
|-- --------------------------
|   SHARED                    # Section label (not collapsible)
|-- --------------------------
|-- Research                  # Shared list (bookmarks + notes)
|-- Work Projects             # Shared list
|-- All                       # All content types
|-- Archived                  # All archived (with type filter)
|-- Trash                     # All deleted (with type filter)
|-- --------------------------
|   BOOKMARKS                 # Section label (collapsible)
|-- --------------------------
|-- All Bookmarks             # Built-in
|-- Reading List              # Bookmark-only custom list
|-- --------------------------
|   NOTES                     # Section label (collapsible)
|-- --------------------------
|-- All Notes                 # Built-in
|-- Meeting Notes             # Note-only custom list
```

**Ordering:** Both sections and items within sections are user-configurable.

---

## Data Model Changes

### New `tab_order` Format

Current format:
```json
["list:123", "all", "archived", "trash"]
```

New format:
```json
{
  "sections": {
    "shared": ["list:456", "all", "archived", "trash"],
    "bookmarks": ["all-bookmarks", "list:123"],
    "notes": ["all-notes", "list:234"]
  },
  "section_order": ["shared", "bookmarks", "notes"]
}
```

### ContentList Model (renamed from BookmarkList)

```python
class ContentList(Base, TimestampMixin):
    __tablename__ = "content_lists"  # New table name

    id: int
    user_id: int (FK -> User, CASCADE)
    name: str (max 100)
    content_types: list[str]  # JSONB: ["bookmark"], ["note"], ["bookmark", "note"]
    filter_expression: JSONB  # Existing tag filter logic
    default_sort_by: str | None
    default_sort_ascending: bool | None
```

---

## Milestones

---

### Milestone 1: Note Model and Database Schema

**Goal:** Create the Note model, NoteVersion table (schema only), and note_tags junction table.

**Dependencies:** None

**Success Criteria:**
- [ ] `Note` model exists with all fields (including `description`)
- [ ] `NoteVersion` model exists (empty, for future use)
- [ ] `note_tags` junction table exists with `ix_note_tags_tag_id` index
- [ ] Alembic migration runs successfully
- [ ] All models have proper indexes and constraints
- [ ] `test_user_cascade.py` updated to include notes in cascade delete tests

**Key Changes:**

1. Create `backend/src/models/note.py`:
   ```python
   class Note(Base, TimestampMixin):
       __tablename__ = "notes"

       id: Mapped[int] = mapped_column(primary_key=True)
       user_id: Mapped[int] = mapped_column(ForeignKey("users.id", ondelete="CASCADE"), index=True)
       title: Mapped[str] = mapped_column(String(500))  # Required, unlike bookmark
       description: Mapped[str | None] = mapped_column(Text, nullable=True)  # Optional metadata
       content: Mapped[str | None] = mapped_column(Text, nullable=True)  # Markdown, up to 2MB
       version: Mapped[int] = mapped_column(default=1)  # For future version history
       last_used_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), server_default=func.clock_timestamp(), index=True)
       deleted_at: Mapped[datetime | None] = mapped_column(DateTime(timezone=True), nullable=True, index=True)
       archived_at: Mapped[datetime | None] = mapped_column(DateTime(timezone=True), nullable=True)

       # Relationships
       user: Mapped["User"] = relationship("User", back_populates="notes")
       tag_objects: Mapped[list["Tag"]] = relationship("Tag", secondary="note_tags", ...)
   ```

   **Why title is required for Notes but optional for Bookmarks:**
   - Bookmarks have a URL that serves as a natural identifier and fallback display name
   - Notes have no URL, so title is the primary identifier for display in lists
   - When filtering mixed ContentLists by title, bookmarks without titles display their URL instead

   **Why description exists on Notes:**
   - Provides searchable metadata separate from content
   - Useful for display in lists (short summary)
   - Future-proofing: if content is encrypted, description can remain unencrypted for search/display

2. Create `backend/src/models/note_version.py`:
   ```python
   class NoteVersion(Base):
       """Schema for future version history. Not actively used yet."""
       __tablename__ = "note_versions"

       id: Mapped[int] = mapped_column(primary_key=True)
       note_id: Mapped[int] = mapped_column(ForeignKey("notes.id", ondelete="CASCADE"), index=True)
       version: Mapped[int]
       version_type: Mapped[str] = mapped_column(String(20))  # "snapshot" | "diff"
       content: Mapped[str] = mapped_column(Text)
       saved_at: Mapped[datetime] = mapped_column(DateTime(timezone=True), default=func.now())
   ```

3. Create `note_tags` junction table (similar to `bookmark_tags`)

4. Update `backend/src/models/__init__.py` to export new models

5. Update `User` model to add `notes` relationship

6. Create Alembic migration

**Testing Strategy:**

Follow existing test patterns - there is no `backend/tests/models/` directory for bookmark tests.
Model behavior is tested through service tests and the cascade test.

- **Update `backend/tests/services/test_user_cascade.py`:**
  - Add notes to the comprehensive cascade delete test
  - Create notes with tags for the test user
  - Verify notes are deleted when user is deleted
  - Verify note_tags junction entries are deleted
  - Verify NoteVersion rows are deleted (if any exist)

- **Defer other model tests to Milestone 3** (service layer tests will exercise model behavior)

**Risk Factors:**
- Ensure 2MB content limit is enforced at database level if needed
- Junction table naming consistency with existing patterns

---

### Milestone 2: Note Schemas

**Goal:** Create Pydantic schemas for Note CRUD operations.

**Dependencies:** Milestone 1

**Success Criteria:**
- [ ] `NoteCreate`, `NoteUpdate`, `NoteListItem`, `NoteResponse` schemas exist
- [ ] Validation matches bookmark patterns (tag normalization, length limits)
- [ ] 2MB content limit enforced
- [ ] All schemas have comprehensive tests

**Key Changes:**

1. Create `backend/src/schemas/note.py`:
   ```python
   class NoteCreate(BaseModel):
       title: str  # Required
       description: str | None = None
       content: str | None = None
       tags: list[str] = []
       archived_at: datetime | None = None

       # Validators for title length, content length (2MB), tag normalization

   class NoteUpdate(BaseModel):
       title: str | None = None
       description: str | None = None
       content: str | None = None
       tags: list[str] | None = None
       archived_at: datetime | None = None

   class NoteListItem(BaseModel):
       """For list views - excludes content for performance."""
       id: int
       title: str
       description: str | None
       tags: list[str]
       created_at: datetime
       updated_at: datetime
       last_used_at: datetime
       deleted_at: datetime | None
       archived_at: datetime | None
       version: int
       # Note: NO content field (too large for list views)

   class NoteResponse(NoteListItem):
       """Full note detail including content."""
       content: str | None
   ```

2. Update `backend/src/schemas/__init__.py`

3. Add `max_note_content_length: int = 500_000` to `core/config.py`

**Testing Strategy:**
- Test tag validation (lowercase, hyphen format)
- Test title length validation
- Test content length validation (up to 500KB, reject larger)
- Test archived_at timezone handling
- Test NoteListItem excludes content
- Test model_validate from ORM objects

**Risk Factors:**
- Ensure validators match bookmark schema patterns exactly for consistency

---

### Milestone 3: Note Service Layer

**Goal:** Create the note service with full CRUD, search, archive, and soft delete.

**Dependencies:** Milestones 1, 2

**Success Criteria:**
- [ ] `create_note`, `get_note`, `update_note`, `delete_note` functions
- [ ] `search_notes` with text search, tag filtering, sorting, pagination
- [ ] `archive_note`, `unarchive_note`, `restore_note` functions
- [ ] All edge cases handled (not found, already deleted, etc.)
- [ ] Comprehensive test coverage

**Key Changes:**

1. Create `backend/src/services/note_service.py`:
   - Mirror `bookmark_service.py` patterns exactly
   - Functions:
     - `create_note(session, user_id, note_data) -> Note`
     - `get_note(session, user_id, note_id) -> Note | None`
     - `get_notes(session, user_id, ...) -> tuple[list[Note], int]` (with search/filter/sort/pagination)
     - `update_note(session, user_id, note_id, note_data) -> Note`
     - `delete_note(session, user_id, note_id) -> None` (soft delete)
     - `restore_note(session, user_id, note_id) -> Note`
     - `archive_note(session, user_id, note_id) -> Note`
     - `unarchive_note(session, user_id, note_id) -> Note`
   - Full-text search on title + description + content
   - Tag filtering with AND/OR modes
   - Reuse `build_filter_from_expression()` pattern from bookmark_service

2. Add custom exceptions in service or dedicated exceptions file:
   - `NoteNotFoundError`
   - `InvalidNoteStateError`

**Testing Strategy:**
- Test CRUD operations for notes
- Test search with query text
- Test tag filtering (AND mode, OR mode)
- Test sorting by all supported fields
- Test pagination (offset, limit, total count)
- Test soft delete (deleted_at set, not actually removed)
- Test restore from trash
- Test archive/unarchive
- Test user isolation (user A cannot see user B's notes)
- Test cascade delete when user is deleted

**Risk Factors:**
- Full-text search index may need specific handling for large content
- Ensure query performance with proper indexes

---

### Milestone 4: Note API Endpoints

**Goal:** Create the REST API endpoints for notes.

**Dependencies:** Milestone 3

**Success Criteria:**
- [ ] All CRUD endpoints work correctly
- [ ] Proper authentication (Auth0 + PAT)
- [ ] Rate limiting applied
- [ ] OpenAPI documentation generated
- [ ] Integration tests pass

**Key Changes:**

1. Create `backend/src/api/routers/notes.py`:
   ```python
   router = APIRouter(prefix="/notes", tags=["notes"])

   @router.post("/", response_model=NoteResponse, status_code=201)
   @router.get("/", response_model=NoteListResponse)
   @router.get("/{note_id}", response_model=NoteResponse)
   @router.patch("/{note_id}", response_model=NoteResponse)
   @router.delete("/{note_id}", status_code=204)
   @router.post("/{note_id}/archive", response_model=NoteResponse)
   @router.post("/{note_id}/unarchive", response_model=NoteResponse)
   @router.post("/{note_id}/restore", response_model=NoteResponse)
   ```

2. Register router in `backend/src/api/main.py`

3. Apply rate limiting:
   - Read operations: standard read tier
   - Write operations: standard write tier
   - No "sensitive" tier needed (no external HTTP requests)

**Testing Strategy:**
- Test all endpoints with valid requests
- Test authentication (401 without token)
- Test authorization (403 for wrong user's notes)
- Test validation errors (400 for invalid input)
- Test not found (404)
- Test rate limiting headers present
- Test pagination parameters
- Test search query parameter
- Test tag filtering parameters

**Risk Factors:**
- Ensure router prefix doesn't conflict with existing routes

---

### Milestone 5: ContentList Refactor (Backend)

**Goal:** Rename BookmarkList to ContentList and add content_types field.

**Dependencies:** Milestone 4

**Success Criteria:**
- [ ] `BookmarkList` model renamed to `ContentList`
- [ ] `bookmark_lists` table renamed to `content_lists`
- [ ] `content_types` field added with proper migration
- [ ] Existing lists migrated with `content_types: ["bookmark"]`
- [ ] Service and router updated
- [ ] All bookmark list functionality still works
- [ ] Tests updated and passing

**Key Changes:**

1. Rename model file: `bookmark_list.py` -> `content_list.py`

2. Update model:
   ```python
   class ContentList(Base, TimestampMixin):
       __tablename__ = "content_lists"

       # ... existing fields ...
       content_types: Mapped[list[str]] = mapped_column(
           JSONB,
           nullable=False,
           default=["bookmark"],
           comment="Content types this list applies to: bookmark, note, todo",
       )
   ```

3. Create Alembic migration:
   - Always use command in Makefile to create Alembic migration, do not create manually
   - Rename table `bookmark_lists` -> `content_lists`
   - Add `content_types` column with default `["bookmark"]`
   - Update existing rows to have `["bookmark"]`

4. Rename service: `bookmark_list_service.py` -> `content_list_service.py`
   - Update all function names, references, and tests
   - Add `content_types` parameter to create/update

5. Rename router: `routers/lists.py` stays but update internals
   - Endpoint paths stay at `/lists/`

6. Update schemas: `bookmark_list.py` -> `content_list.py`
   - Add `content_types` field to create/update/response schemas

7. Update User model relationship: `bookmark_lists` -> `content_lists`

8. Update all imports throughout codebase

**Testing Strategy:**
- Test existing list functionality still works
- Test creating list with single content type
- Test creating list with multiple content types
- Test filtering lists by content type
- Test migration runs correctly
- Test existing lists have content_types: ["bookmark"]

**Risk Factors:**
- This is a breaking change - all frontend code referencing "BookmarkList" must update
- Ensure all foreign key references update correctly

---

### Milestone 6: Tab Order Migration (Backend)

**Goal:** Migrate tab_order to new structured format supporting sections.

**Dependencies:** Milestone 5

**Success Criteria:**
- [ ] New tab_order format supported
- [ ] Migration converts existing data
- [ ] Settings service updated
- [ ] API handles new format
- [ ] Old format no longer supported (clean break)

**Key Changes:**

1. Update `UserSettings` model:
   - No schema change needed (JSONB is flexible)
   - Document new format in comments

2. Create migration to transform existing data:

   - Always use command in Makefile to create Alembic migration, do not create manually


   ```python
   # Old: ["list:123", "all", "archived", "trash"]
   # New: {
   #   "sections": {
   #     "shared": ["all", "archived", "trash"],
   #     "bookmarks": ["all-bookmarks", "list:123"],
   #     "notes": ["all-notes"]
   #   },
   #   "section_order": ["shared", "bookmarks", "notes"]
   # }
   ```

3. Update `settings_service.py`:
   - `get_tab_order()` returns new format
   - `update_tab_order()` accepts new format
   - `add_list_to_tab_order()` updated for sections
   - `remove_list_from_tab_order()` updated for sections

4. Update `user_settings` schema:
   - Define new TabOrder structure with proper Pydantic models

5. Update settings router endpoints

**Testing Strategy:**
- Test migration converts old format correctly
- Test new users get default structured tab_order
- Test adding list to correct section (based on content_types)
- Test removing list from section
- Test section ordering
- Test item ordering within section

**Risk Factors:**
- Data migration must handle edge cases (null tab_order, malformed data)
- Frontend must update simultaneously

---

### Milestone 7: Notes Frontend - Types and API Client

**Goal:** Add TypeScript types and API client functions for notes.

**Dependencies:** Milestone 4

**Success Criteria:**
- [ ] Note types defined in types.ts
- [ ] API client functions for all note endpoints
- [ ] Types match backend schemas exactly

**Key Changes:**

1. Update `frontend/src/types.ts`:
   ```typescript
   export interface NoteListItem {
     id: number
     title: string
     description: string | null
     tags: string[]
     created_at: string
     updated_at: string
     last_used_at: string
     deleted_at: string | null
     archived_at: string | null
     version: number
   }

   export interface Note extends NoteListItem {
     content: string | null
   }

   export interface NoteCreate {
     title: string
     description?: string | null
     content?: string | null
     tags?: string[]
     archived_at?: string | null
   }

   export interface NoteUpdate {
     title?: string
     description?: string | null
     content?: string | null
     tags?: string[]
     archived_at?: string | null
   }

   export interface NoteListResponse {
     items: NoteListItem[]
     total: number
     offset: number
     limit: number
     has_more: boolean
   }
   ```

2. Update `frontend/src/services/api.ts`:
   - Add note API functions matching bookmark patterns

3. Update ContentList types:
   ```typescript
   export interface ContentList {
     id: number
     name: string
     content_types: ('bookmark' | 'note')[]
     filter_expression: FilterExpression
     default_sort_by: string | null
     default_sort_ascending: boolean | null
   }
   ```

**Testing Strategy:**
- Type checking via TypeScript compiler
- Verify API functions return expected types

**Risk Factors:**
- Keep types in sync with backend schemas

---

### Milestone 8: Notes Frontend - Hooks and Store

**Goal:** Create React hooks and Zustand stores for notes using TanStack Query.

**Dependencies:** Milestone 7

**Success Criteria:**
- [ ] `noteKeys` query key factory created
- [ ] `useNotesQuery` hook with TanStack Query caching
- [ ] `useNoteMutations` hooks with proper cache invalidation
- [ ] `useNotes` hook for non-cached utilities
- [ ] Query invalidation works correctly across views

**Key Changes:**

**IMPORTANT:** Follow the existing TanStack Query patterns in `useBookmarksQuery.ts` and `useBookmarkMutations.ts` exactly. These files are the reference implementation.

1. Create `frontend/src/hooks/useNotes.ts`:
   - `fetchNote(id)` - get full note with content
   - `trackNoteUsage(id)` - update last_used_at

2. Create `frontend/src/hooks/useNotesQuery.ts`:

   **Reference:** `frontend/src/hooks/useBookmarksQuery.ts`

   ```typescript
   // Query key factory - same pattern as bookmarkKeys
   export const noteKeys = {
     all: ['notes'] as const,
     lists: () => [...noteKeys.all, 'list'] as const,
     view: (view: 'active' | 'archived' | 'deleted') =>
       [...noteKeys.lists(), view] as const,
     customLists: () => [...noteKeys.lists(), 'custom'] as const,
     list: (params: NoteSearchParams) => {
       if (params.list_id !== undefined) {
         return [...noteKeys.customLists(), params] as const
       }
       return [...noteKeys.view(params.view ?? 'active'), params] as const
     },
   }

   // Query hook
   export function useNotesQuery(
     params: NoteSearchParams,
     options: UseNotesQueryOptions = {}
   ) {
     const { enabled = true } = options
     return useQuery({
       queryKey: noteKeys.list(params),
       queryFn: () => fetchNotes(params),
       enabled,
     })
   }
   ```

3. Create `frontend/src/hooks/useNoteMutations.ts`:

   **Reference:** `frontend/src/hooks/useBookmarkMutations.ts`

   Follow the same cache invalidation strategy:
   | Mutation          | Invalidates                              |
   |-------------------|------------------------------------------|
   | Create note       | active, custom lists                     |
   | Update note       | active, archived, custom lists           |
   | Delete (soft)     | active, deleted, custom lists            |
   | Delete (permanent)| deleted only                             |
   | Archive           | active, archived, custom lists           |
   | Unarchive         | active, archived, custom lists           |
   | Restore           | active, deleted, custom lists            |

   ```typescript
   export function useCreateNote() {
     const queryClient = useQueryClient()
     const fetchTags = useTagsStore((state) => state.fetchTags)

     return useMutation({
       mutationFn: async (data: NoteCreate): Promise<Note> => {
         const response = await api.post<Note>('/notes/', data)
         return response.data
       },
       onSuccess: () => {
         queryClient.invalidateQueries({ queryKey: noteKeys.view('active') })
         queryClient.invalidateQueries({ queryKey: noteKeys.customLists() })
         fetchTags()
       },
     })
   }
   // ... same pattern for useUpdateNote, useDeleteNote, etc.
   ```

4. Share existing stores:
   - `useTagFilterStore` - tags are shared across content types
   - `useTagsStore` - tag list is shared

**Why not a generic abstraction?**

The bookmark TanStack Query code is ~200 lines total. Creating a generic `useContentQuery<T>` would add abstraction complexity without meaningful code savings. The pattern is clear - follow it for notes. If a third content type (todos) is added and patterns diverge, consider refactoring then.

**Testing Strategy:**
- Test hooks return expected data shapes
- Test mutation invalidation clears correct views
- Test error handling in hooks
- Test cache keys are correctly structured

**Risk Factors:**
- Query key design must allow proper invalidation

---

### Milestone 9: Notes Frontend - Components

**Goal:** Create the Note UI components.

**Dependencies:** Milestone 8

**Success Criteria:**
- [ ] `NoteCard` component for list view
- [ ] `NoteView` component for rendered markdown view
- [ ] `NoteEditor` component for editing
- [ ] Components handle all states (loading, error, empty)

**Key Changes:**

1. Create `frontend/src/components/NoteCard.tsx`:
   - Similar to BookmarkCard but without URL/favicon
   - Shows title, description (if present, else truncated content preview), tags, dates
   - Context-aware actions (edit, archive, delete, restore)

2. Create `frontend/src/components/NoteView.tsx`:
   - Renders markdown content
   - Shows title, tags, metadata
   - Edit button to switch modes
   - Use a markdown rendering library (e.g., `react-markdown` with `remark-gfm`)
   - **Security:** Sanitize HTML output (use `rehype-sanitize`)

3. Create `frontend/src/components/NoteEditor.tsx`:
   - CodeMirror editor with markdown syntax highlighting (`@uiw/react-codemirror`)
   - Title input field
   - Description input field (optional, for metadata/summary)
   - Tag input (reuse existing `TagInput` component)
   - Save and Cancel buttons
   - Optional: Preview toggle (side-by-side or switch)
   - Keyboard shortcuts: Cmd+S to save, Esc to cancel

   **Draft autosave to localStorage:**
   - Key structure: `note_draft_${noteId}` for existing notes, `note_draft_new` for new notes
   - Save draft every 30 seconds while editing
   - Clear draft on successful save
   - On component mount: check for existing draft and prompt to restore
   - Multi-tab handling: Last write wins (localStorage is shared across tabs)

4. Create `frontend/src/components/NoteForm.tsx`:
   - Wrapper that coordinates view/edit modes
   - Handles API calls for save

**Testing Strategy:**
- Test NoteCard renders all states
- Test NoteView renders markdown correctly
- Test NoteEditor form submission
- Test keyboard shortcuts
- Test draft recovery

**Risk Factors:**
- Markdown rendering security (XSS prevention)
- Large content performance in editor

---

### Milestone 10: Notes Frontend - Pages

**Goal:** Create the Notes page with list and detail views.

**Dependencies:** Milestone 9

**Success Criteria:**
- [ ] `/app/notes` - Notes list view
- [ ] `/app/notes/:id` - Note view mode
- [ ] `/app/notes/:id/edit` - Note edit mode
- [ ] `/app/notes/new` - Create new note
- [ ] Search, filter, sort, pagination working
- [ ] Navigation between list and detail works

**Key Changes:**

1. Create `frontend/src/pages/Notes.tsx`:
   - Mirror Bookmarks.tsx structure
   - Search input with debounce
   - Tag filter (reuse TagFilterInput)
   - View selector (Active/Archived/Deleted)
   - Sort controls
   - Pagination
   - Note list with NoteCard components
   - "New Note" button

2. Create `frontend/src/pages/NoteDetail.tsx`:
   - Route: `/app/notes/:id` and `/app/notes/:id/edit`
   - Back button to return to list
   - Renders NoteView or NoteEditor based on route/mode
   - Save navigates to view mode
   - Cancel returns to view mode (or list if new)

3. Update `frontend/src/App.tsx` (or router config):
   - Add routes for notes pages

**Testing Strategy:**
- Test list renders correctly
- Test navigation to detail view
- Test edit mode toggle
- Test create new note flow
- Test search updates results
- Test pagination controls
- Test view switching (active/archived/deleted)

**Risk Factors:**
- Route structure must be intuitive
- State management between list and detail views

---

### Milestone 11: Sidebar Refactor (Frontend)

**Goal:** Implement new unified navigation structure with sections.

**Dependencies:** Milestones 6, 10

**Success Criteria:**
- [ ] New sidebar structure with SHARED, BOOKMARKS, NOTES sections
- [ ] Section ordering configurable
- [ ] Item ordering within sections configurable
- [ ] Collapsible type-specific sections (BOOKMARKS, NOTES)
- [ ] Non-collapsible SHARED section
- [ ] Lists appear in correct section based on content_types

**Key Changes:**

1. Update `frontend/src/components/sidebar/Sidebar.tsx`:
   - Render sections based on new tab_order format
   - SHARED section: non-collapsible, contains shared lists + All/Archived/Trash
   - BOOKMARKS section: collapsible, contains bookmark-only lists + All Bookmarks
   - NOTES section: collapsible, contains note-only lists + All Notes

2. Update `frontend/src/stores/settingsStore.ts`:
   - Parse new tab_order format
   - Compute section data from format

3. Update `frontend/src/components/sidebar/routes.ts`:
   - Add note routes
   - Add section-aware route generation

4. Update icons:
   - Bookmark icon for bookmark-only items
   - Note icon for note-only items
   - Combined/collection icon for shared items

5. Update list creation modal to show content_types selection

**Testing Strategy:**
- Test sections render in correct order
- Test items within sections render in correct order
- Test collapsible sections work
- Test navigation to correct routes
- Test list appears in correct section based on content_types

**Risk Factors:**
- Complex state management for section ordering
- Need to handle migration from old sidebar structure

---

### Milestone 12: Unified Search Endpoint and MCP Tools

**Goal:** Add unified search backend endpoint and MCP tools for notes.

**Dependencies:** Milestones 3, 4

**Success Criteria:**
- [ ] `GET /content/search` backend endpoint works
- [ ] `search_content` MCP tool works (unified search)
- [ ] `get_note` MCP tool works
- [ ] `create_note` MCP tool works
- [ ] MCP server instructions updated
- [ ] Existing `search_bookmarks` MCP tool removed (replaced by `search_content`)

**Key Changes:**

1. **Create unified search backend endpoint** `backend/src/api/routers/content.py`:
   ```python
   router = APIRouter(prefix="/content", tags=["content"])

   @router.get("/search", response_model=UnifiedSearchResponse)
   async def search_content(
       q: str | None = None,
       content_types: list[str] = Query(default=["bookmark", "note"]),
       tags: list[str] | None = Query(default=None),
       tag_match: Literal["all", "any"] = "all",
       sort_by: str = "created_at",
       sort_order: Literal["asc", "desc"] = "desc",
       limit: int = Query(default=50, ge=1, le=100),
       offset: int = Query(default=0, ge=0),
   ):
       """Search across content types. Returns grouped results with per-type pagination."""
   ```

2. **Create content service** `backend/src/services/content_service.py`:
   ```python
   async def search_content(
       session, user_id, types, query, tags, ...
   ) -> dict:
       """
       Calls bookmark_service.search_bookmarks() and/or note_service.search_notes()
       based on requested types. Returns grouped results.
       """
   ```

3. **Update MCP tools** in `backend/src/mcp_server/server.py`:

   **Remove:** `search_bookmarks` tool (replaced by unified search)

   **Keep:** `list_tags` (shared)

   **Add:**
   ```python
   @mcp.tool(description="Search across content types (bookmarks, notes). Use content_types to filter.")
   async def search_content(
       query: str | None = None,
       content_types: list[Literal["bookmark", "note"]] = ["bookmark", "note"],
       tags: list[str] | None = None,
       tag_match: Literal["all", "any"] = "all",
       sort_by: Literal["created_at", "updated_at", "last_used_at", "title"] = "created_at",
       sort_order: Literal["asc", "desc"] = "desc",
       limit: int = 50,
       offset: int = 0,
   ) -> dict[str, Any]:
       """
       Unified search. Returns results GROUPED BY TYPE.
       - To search only bookmarks: content_types=["bookmark"]
       - To search only notes: content_types=["note"]
       - To search all: content_types=["bookmark", "note"] (default)
       """

   @mcp.tool(description="Get full details of a specific note including content.")
   async def get_note(note_id: int) -> dict[str, Any]: ...

   @mcp.tool(description="Create a new note.")
   async def create_note(
       title: str,
       description: str | None = None,
       content: str | None = None,
       tags: list[str] | None = None,
   ) -> dict[str, Any]: ...
   ```

   **Final MCP tool list:**
   - `search_content` - unified search (replaces `search_bookmarks`)
   - `get_bookmark` - get single bookmark (keep existing)
   - `get_note` - get single note (new)
   - `create_bookmark` - create bookmark (keep existing)
   - `create_note` - create note (new)
   - `list_tags` - list all tags (keep existing)

4. **Unified search response structure:**
   ```json
   {
     "bookmarks": {
       "items": [...],
       "total": 45,
       "offset": 0,
       "limit": 50,
       "has_more": false
     },
     "notes": {
       "items": [...],
       "total": 12,
       "offset": 0,
       "limit": 50,
       "has_more": false
     }
   }
   ```

   **Pagination clarification:** This endpoint returns **grouped results** with per-type pagination. Each content type has its own offset/limit/total. This design is intended for:
   - "All" views that display bookmarks and notes in separate sections
   - Dashboards showing recent items from each type

   If the frontend wants to display interleaved results (mixed bookmarks and notes sorted together), it should:
   - Fetch both types with the same sort order
   - Merge and sort client-side
   - Handle pagination per-type independently

   This is NOT designed for server-side interleaved pagination (which would require a different query architecture).

5. Update MCP server instructions to document the consolidated tool set

**Testing Strategy:**
- Test `GET /content/search` with various type combinations
- Test unified search returns correct grouped structure
- Test MCP `search_content` tool with all type filters
- Test `search_content(content_types=["bookmark"])` returns only bookmarks
- Test error handling (not found, invalid parameters)
- Test authentication works
- Verify `search_bookmarks` MCP tool no longer exists

**Risk Factors:**
- Need to update any existing MCP clients that use `search_bookmarks` to use `search_content`

---

### Milestone 13: Settings and List Management Updates

**Goal:** Update settings pages for new list/content structure.

**Dependencies:** Milestones 5, 6, 11

**Success Criteria:**
- [ ] "Bookmarks" settings renamed to "Lists" or "Custom Lists"
- [ ] List creation allows selecting content_types
- [ ] List editing allows updating content_types
- [ ] Tab order editor works with new format

**Key Changes:**

1. Update settings navigation:
   - Rename "Bookmarks" to "Lists" or "Custom Lists"

2. Update `ListModal.tsx`:
   - Add content_types selector (checkboxes for bookmark, note)
   - **Default to all types checked** for new lists (confirmed decision)

3. Update `TabOrderEditor.tsx`:
   - Handle new section-based format
   - Allow reordering sections
   - Allow reordering items within sections

4. Update `ListManager.tsx`:
   - Show content_types on list cards
   - Filter by content_type if needed

**Testing Strategy:**
- Test creating list with single content type
- Test creating list with multiple content types
- Test editing list content types
- Test tab order editing with sections
- Test section reordering

**Risk Factors:**
- Complex UI for section-aware ordering

---

### Milestone 14: Security Testing

**Goal:** Comprehensive security testing for all new functionality following existing patterns in `backend/tests/security/`.

**Dependencies:** Milestones 4, 5, 12

**Success Criteria:**
- [ ] IDOR tests for notes (all CRUD operations)
- [ ] IDOR tests for content lists
- [ ] IDOR tests for unified search endpoint
- [ ] Input validation tests for notes
- [ ] Live penetration tests updated for notes
- [ ] All security tests passing

**Key Changes:**

1. **Update `test_idor.py`** - Add note and content list IDOR tests:
   ```python
   class TestNoteIDOR:
       """Test IDOR protection for note resources."""

       async def test__get_note__returns_404_for_other_users_note(...)
       async def test__update_note__returns_404_for_other_users_note(...)
       async def test__delete_note__returns_404_for_other_users_note(...)
       async def test__archive_note__returns_404_for_other_users_note(...)
       async def test__list_notes__excludes_other_users_data(...)

   class TestContentListIDOR:
       """Test IDOR protection for content list resources."""

       async def test__get_list__returns_404_for_other_users_list(...)
       async def test__update_list__returns_404_for_other_users_list(...)
       async def test__delete_list__returns_404_for_other_users_list(...)

   class TestUnifiedSearchIDOR:
       """Test IDOR protection for unified search endpoint."""

       async def test__content_search__excludes_other_users_bookmarks(...)
       async def test__content_search__excludes_other_users_notes(...)
   ```

2. **Update `test_input_validation.py`** - Add note-specific tests:
   ```python
   class TestNoteSQLInjectionPrevention:
       """Test SQL injection prevention for notes."""

       async def test__note_search_query__handles_sql_injection_payloads(...)
       async def test__note_title__handles_sql_injection_payload(...)
       async def test__note_content__handles_sql_injection_payload(...)

   class TestNoteXSSPrevention:
       """Test XSS prevention for notes."""

       async def test__note_fields__store_xss_payloads_without_execution(...)
       async def test__note_content_markdown__stores_xss_safely(...)

   class TestNoteInputLengthLimits:
       """Test note input length validation."""

       async def test__note_title_at_max_length__is_accepted(...)  # 500 chars
       async def test__note_title_over_max_length__is_rejected(...)
       async def test__note_content_at_max_length__is_accepted(...)  # 2MB
       async def test__note_content_over_max_length__is_rejected(...)

   class TestUnifiedSearchInputValidation:
       """Test unified search input validation."""

       async def test__content_types_parameter__rejects_invalid_types(...)
       async def test__unified_search__handles_sql_injection_payloads(...)
   ```

3. **Update `test_authentication.py`** - Add note endpoints:
   ```python
   @pytest.mark.parametrize(("endpoint", "method"), [
       # ... existing endpoints ...
       ("/notes/", "GET"),
       ("/content/search", "GET"),
   ])
   async def test__protected_endpoint__requires_authentication(...)
   ```

4. **Update `test_live_penetration.py`** - Add note penetration tests:
   ```python
   class TestNoteIDOR:
       """Verify users cannot access other users' notes."""

       async def test__cross_user_note_access__returns_404(...)
       async def test__cross_user_note_update__returns_404(...)
       async def test__cross_user_note_delete__returns_404(...)
       async def test__note_list__excludes_other_users_data(...)

   class TestUnifiedSearchIsolation:
       """Verify unified search respects user isolation."""

       async def test__unified_search__excludes_other_users_bookmarks(...)
       async def test__unified_search__excludes_other_users_notes(...)

   class TestContentListIDOR:
       """Verify users cannot access other users' content lists."""

       async def test__cross_user_list_access__returns_404(...)
       async def test__cross_user_list_update__returns_404(...)
       async def test__cross_user_list_delete__returns_404(...)
   ```

5. **Add `conftest.py` fixtures** for notes:
   ```python
   @pytest.fixture
   async def user_a_note(session, user_a) -> Note:
       """Create a note owned by User A."""

   @pytest.fixture
   async def user_b_note(session, user_b) -> Note:
       """Create a note owned by User B."""

   @pytest.fixture
   async def user_a_content_list(session, user_a) -> ContentList:
       """Create a content list owned by User A."""
   ```

**Testing Strategy:**
- Follow existing test patterns exactly (test naming, assertions, cleanup)
- Return 404 (not 403) for IDOR to prevent ID enumeration
- Test both unit tests (mocked) and live penetration tests (deployed)
- Test edge cases: archived notes, deleted notes, mixed content types

**OWASP Coverage:**
- A01:2021 - Broken Access Control (IDOR tests)
- A03:2021 - Injection (SQL injection, XSS tests)
- A07:2021 - Identification and Authentication Failures (auth tests)

**Risk Factors:**
- Live penetration tests require deployed environment with test users
- Need to create test notes without polluting production data

---

### Milestone 15: Documentation and Cleanup

**Goal:** Update all documentation and ensure code quality.

**Dependencies:** All previous milestones

**Success Criteria:**
- [ ] CLAUDE.md updated with notes information
- [ ] API documentation accurate
- [ ] No dead code or unused imports
- [ ] Consistent naming throughout
- [ ] All tests passing
- [ ] Linting clean

**Key Changes:**

1. Update `CLAUDE.md`:
   - Add notes endpoints documentation
   - Update rate limiting table if changed
   - Document new navigation structure
   - Document MCP tools for notes

2. Remove any backwards compatibility code

3. Run linting and fix issues:
   - `make linting` for backend
   - `npm run lint` for frontend

4. Review for dead code:
   - Old BookmarkList references
   - Old tab_order format handling
   - Unused imports

5. Ensure test coverage:
   - Run `make tests`
   - Verify coverage for new code

**Testing Strategy:**
- Full test suite passes
- Manual testing of all flows
- Review documentation accuracy

**Risk Factors:**
- May discover edge cases during final testing

---

## Summary

| Milestone | Description | Backend | Frontend | MCP |
|-----------|-------------|---------|----------|-----|
| 1 | Note Model & DB Schema | Yes | - | - |
| 2 | Note Schemas | Yes | - | - |
| 3 | Note Service Layer | Yes | - | - |
| 4 | Note API Endpoints | Yes | - | - |
| 5 | ContentList Refactor | Yes | - | - |
| 6 | Tab Order Migration | Yes | - | - |
| 7 | Frontend Types & API | - | Yes | - |
| 8 | Frontend Hooks & Store | - | Yes | - |
| 9 | Frontend Components | - | Yes | - |
| 10 | Frontend Pages | - | Yes | - |
| 11 | Sidebar Refactor | - | Yes | - |
| 12 | Unified Search & MCP Tools | Yes | - | Yes |
| 13 | Settings Updates | - | Yes | - |
| 14 | Security Testing | Yes | - | - |
| 15 | Documentation & Cleanup | Yes | Yes | Yes |

---

## Resolved Questions

All questions have been answered:

1. **Content length for notes:** 2MB confirmed
2. **Markdown editor:** CodeMirror (`@uiw/react-codemirror`) for editing with syntax highlighting + react-markdown/remark-gfm/rehype-sanitize for viewing. Fallback to textarea if CodeMirror causes issues.
3. **Unified search format:** Grouped by type with separate pagination per type. Frontend can choose to display separately or interleave.
4. **Default list behavior:** Default to all content types checked when creating new lists.
